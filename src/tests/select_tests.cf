// vim: syntax=c
/**
 * @file: select_tests.cf
 *
 * @description: Unit tests for core/select.h/c.
 *
 * @author: Peter Mawhorter (pmawhorter@gmail.com)
 */

#include <stdio.h>
#include <sys/stat.h> // for chmod

#include "core/select.h"

int myc_test_parent_child_selection() {
  id parent, index;
  id max_arity = 16;
  id avg_arity = 4;
  id seed = 46571;
  id result;
  for (id tin = 102012; tin < 1928012; tin += 331) {
    myc_select_parent_and_index(
      tin,
      avg_arity,
      max_arity,
      seed,
      &parent,
      &index
    );
    result = myc_select_nth_child(parent, index, avg_arity, max_arity, seed);
    if (result != tin) {
      fprintf(
        stderr,
        "Selection reversibility failed: %lu → %lu#%lu / %lu#%lu → %lu\n",
        tin, parent, index, parent, index, result
      );
      fprintf(stderr, "All children of %lu:\n", parent);
      id nth = 0;
      id child = NONE;
      do {
        child = myc_select_nth_child(parent, nth, avg_arity, max_arity, seed);
        fprintf(stderr, "  #%lu: %lu\n", nth, child);
        nth += 1;
      } while (child != NONE);
      return tin;
    }
  }
  return 0;
}

int myc_test_odd_parent_child_selection() {
  id parent, index;
  id max_arity = 23;
  id avg_arity = 3;
  id seed = 1028101;
  id result;
  for (id tin = 40192; tin < 524011; tin += 1873) {
    myc_select_parent_and_index(
      tin,
      avg_arity,
      max_arity,
      seed,
      &parent,
      &index
    );
    result = myc_select_nth_child(parent, index, avg_arity, max_arity, seed);
    if (result != tin) {
      fprintf(
        stderr,
        "Selection reversibility failed: %lu → %lu#%lu / %lu#%lu → %lu\n",
        tin, parent, index, parent, index, result
      );
      fprintf(stderr, "All children of %lu:\n", parent);
      id nth = 0;
      id child = NONE;
      do {
        child = myc_select_nth_child(parent, nth, avg_arity, max_arity, seed);
        fprintf(stderr, "  #%lu: %lu\n", nth, child);
        nth += 1;
      } while (child != NONE);
      return tin;
    }
  }
  return 0;
}

int myc_test_parent_child_visual() {
  id avg_arity = 4, max_arity = 32;
  id parent = 7182;
  id seed = 191284;
  id nth = 0;
  id child = NONE;
  fprintf(stdout, "\n  %lu", parent);
  for (id i = 0; i < 7; ++i) {
      nth = 0;
      fprintf(stdout, "\n    |\n  ");
      while(1) {
        child = myc_select_nth_child(parent, nth, avg_arity, max_arity, seed);
        if (child == NONE) {
          fprintf(stdout, "|");
          break;
        }
        fprintf(stdout, "%lu---", child);
        nth += 1;
      }
      parent = myc_select_nth_child(parent, 0, avg_arity, max_arity, seed);
      if (parent == NONE) {
        break;
      }
  }
  fprintf(stdout, "\n\n");
  return 0;
}

int myc_test_exp_parent_child_selection() {
  id parent, index;
  id max_arity = 32;
  id avg_arity = 1;
  id seed = 798513546;
  float exp_shape = 0.2;
  id exp_size = 1024;
  id result;
  for (id tin = 54646; tin < 9464135; tin += 5167) {
    myc_select_exp_parent_and_index(
      tin,
      avg_arity,
      max_arity,
      exp_shape,
      exp_size,
      seed,
      &parent,
      &index
    );
    result = myc_select_exp_nth_child(
      parent,
      index,
      avg_arity,
      max_arity,
      exp_shape,
      exp_size,
      seed
    );
    if (result != tin) {
      fprintf(
        stderr,
        "Selection reversibility failed: %lu → %lu#%lu / %lu#%lu → %lu\n",
        tin, parent, index, parent, index, result
      );
      fprintf(stderr, "All children of %lu:\n", parent);
      id nth = 0;
      id child = NONE;
      do {
        child = myc_select_exp_nth_child(
          parent,
          nth,
          avg_arity,
          max_arity,
          exp_shape,
          exp_size,
          seed
        );
        fprintf(stderr, "  #%lu: %lu\n", nth, child);
        nth += 1;
      } while (child != NONE);
      return tin;
    }
  }
  return 0;
}

int myc_test_odd_exp_parent_child_selection() {
  id parent, index;
  id max_arity = 37;
  id avg_arity = 3;
  id seed = 17219;
  float exp_shape = 0.3;
  id exp_size = 45;
  id result;
  for (id tin = 389238; tin < 581201; tin += 8756) {
    myc_select_exp_parent_and_index(
      tin,
      avg_arity,
      max_arity,
      exp_shape,
      exp_size,
      seed,
      &parent,
      &index
    );
    result = myc_select_exp_nth_child(
      parent,
      index,
      avg_arity,
      max_arity,
      exp_shape,
      exp_size,
      seed
    );
    if (result != tin) {
      fprintf(
        stderr,
        "Selection reversibility failed: %lu → %lu#%lu / %lu#%lu → %lu\n",
        tin, parent, index, parent, index, result
      );
      fprintf(stderr, "All children of %lu:\n", parent);
      id nth = 0;
      id child = NONE;
      do {
        child = myc_select_exp_nth_child(
          parent,
          nth,
          avg_arity,
          max_arity,
          exp_shape,
          exp_size,
          seed
        );
        fprintf(stderr, "  #%lu: %lu\n", nth, child);
        nth += 1;
      } while (child != NONE);
      return tin;
    }
  }
  return 0;
}

int myc_test_exp_parent_child_visual() {
  id avg_arity = 3, max_arity = 32;
  id parent = 46548464;
  id seed = 172911;
  id nth = 0;
  id child = NONE;
  float exp_cohort_shape = 0.02;
  id exp_cohort_size = 512;
  fprintf(stdout, "\n  %lu", parent);
  for (id i = 0; i < 7; ++i) {
      nth = 0;
      fprintf(stdout, "\n    |\n  ");
      while(1) {
        child = myc_select_exp_nth_child(
          parent,
          nth,
          avg_arity,
          max_arity,
          exp_cohort_shape,
          exp_cohort_size,
          seed
        );
        if (child == NONE) {
          fprintf(stdout, "|");
          break;
        }
        fprintf(stdout, "%lu---", child);
        nth += 1;
      }
      parent = myc_select_exp_nth_child(
        parent,
        0,
        avg_arity,
        max_arity,
        exp_cohort_shape,
        exp_cohort_size,
        seed
      );
      if (parent == NONE) {
        break;
      }
  }
  fprintf(stdout, "\n\n");
  return 0;
}

void myc_print_edges_recursively(
  FILE* stream,
  id parent,
  id avg_arity,
  id max_arity,
  id seed,
  float exp_cohort_shape,
  id exp_cohort_size,
  id depth_limit
) {
  id nth = 0;
  id child;
  while(1) {
    child = myc_select_exp_nth_child(
      parent,
      nth,
      avg_arity,
      max_arity,
      exp_cohort_shape,
      exp_cohort_size,
      seed
    );
    if (child == NONE) {
      break;
    }
    fprintf(stream, "  %lu -> %lu;\n", parent, child);
    nth += 1;
    if (depth_limit > 0) {
      myc_print_edges_recursively(
        stream,
        child,
        avg_arity,
        max_arity,
        seed,
        exp_cohort_shape,
        exp_cohort_size,
        depth_limit - 1
      );
    }
  }
}

int myc_test_exp_select_graphviz() {
  id avg_arity = 1, max_arity = 32;
  id parent;
  id index = 0;
  float exp_cohort_shape = 0.02;
  id exp_cohort_size = 512;
  char filename[1024];
  for (id seed = 172741; seed < 172746; seed += 1) {
    parent = 10000000;
    // find the great-grandparent:
    for (id i = 0; i < 3; ++i) {
      myc_select_exp_parent_and_index(
        parent,
        avg_arity,
        max_arity,
        exp_cohort_shape,
        exp_cohort_size,
        seed,
        &parent,
        &index
      );
    }

    snprintf(filename, 1024, "test/select/exp_select-graph-%lu.gv", seed);
    FILE *fout = fopen(filename, "w");
    // print edges
    fprintf(fout, "digraph G {\n");
    myc_print_edges_recursively(
      fout,
      parent,
      avg_arity,
      max_arity,
      seed,
      exp_cohort_shape,
      exp_cohort_size,
      5
    );
    fprintf(fout, "}\n");
  }
  return 0;
}

int myc_test_avg_parent_child_gap() {
  id parent, index, child;
  id max_arity = 32;
  id avg_arity = 1;
  double avg_parent_distance = 0; 
  double avg_child_distance = 0; 
  id parent_dist_count = 0;
  id child_dist_count = 0;
  id n_samples = 100000;
  int64_t parent_distances[n_samples];
  int64_t child_distances[n_samples];
  int64_t dist;
  id seeds_to_check = 3;
  for (id seed = 301910239812; seed < 301910239812 + seeds_to_check; ++seed) {
    avg_parent_distance = 0; 
    avg_child_distance = 0; 
    parent_dist_count = 0;
    child_dist_count = 0;
    for (id here = 5646461354679; here < 5646461354679 + n_samples; ++here) {
      myc_select_parent_and_index(
        here,
        avg_arity,
        max_arity,
        seed,
        &parent,
        &index
      );
      dist = (int64_t) here - (int64_t) parent;
      parent_distances[parent_dist_count] = dist;
      avg_parent_distance += dist; parent_dist_count += 1;
      child = myc_select_nth_child(
        here,
        0,
        avg_arity,
        max_arity,
        seed
      );
      if (child != NONE) {
        dist = (int64_t) child - (int64_t) here;
        child_distances[child_dist_count] = dist;
        avg_child_distance += dist;
        child_dist_count += 1;
      }
    }
    fprintf(
      stdout,
      "\nAverage parent/child distances [%lu]: %.2f/%.2f\n",
      seed,
      avg_parent_distance / (double) parent_dist_count,
      avg_child_distance / (double) child_dist_count
    );
    fprintf(
      stdout,
      "Sampled %lu parent distances and %lu child distances.\n",
      parent_dist_count,
      child_dist_count
    );
    int64_t min_parent_dist = parent_distances[0];
    int64_t max_parent_dist = parent_distances[0];
    int64_t min_child_dist = child_distances[0];
    int64_t max_child_dist = child_distances[0];
    for (id i = 0; i < parent_dist_count; ++i) {
      if (parent_distances[i] < min_parent_dist) {
        min_parent_dist = parent_distances[i];
      }
      if (parent_distances[i] > max_parent_dist) {
        max_parent_dist = parent_distances[i];
      }
    }
    for (id i = 0; i < child_dist_count; ++i) {
      if (child_distances[i] < min_child_dist) {
        min_child_dist = child_distances[i];
      }
      if (child_distances[i] > max_child_dist) {
        max_child_dist = child_distances[i];
      }
    }
    fprintf(
      stdout,
      "Min--max parent/child distances [%lu]: %ld--%ld / %ld--%ld\n\n",
      seed,
      min_parent_dist,
      max_parent_dist,
      min_child_dist,
      max_child_dist
    );
  }
  return 0;
}

int myc_test_avg_exp_parent_child_gap() {
  id parent, index, child;
  id max_arity = 32;
  id avg_arity = 1;
  float cohort_shape = 0.01;
  id cohort_size = 1024;
  double avg_parent_distance = 0; 
  double avg_child_distance = 0; 
  id parent_dist_count = 0;
  id child_dist_count = 0;
  id n_samples = 10000;
  int64_t parent_distances[n_samples];
  int64_t child_distances[n_samples];
  int64_t dist;
  id seeds_to_check = 3;
  for (id seed = 301910239812; seed < 301910239812 + seeds_to_check; ++seed) {
    avg_parent_distance = 0; 
    avg_child_distance = 0; 
    parent_dist_count = 0;
    child_dist_count = 0;
    for (id here = 5646461354679; here < 5646461354679 + n_samples; ++here) {
      myc_select_exp_parent_and_index(
        here,
        avg_arity,
        max_arity,
        cohort_shape,
        cohort_size,
        seed,
        &parent,
        &index
      );
      dist = (int64_t) here - (int64_t) parent;
      parent_distances[parent_dist_count] = dist;
      avg_parent_distance += dist; parent_dist_count += 1;
      child = myc_select_exp_nth_child(
        here,
        0,
        avg_arity,
        max_arity,
        cohort_shape,
        cohort_size,
        seed
      );
      if (child != NONE) {
        dist = (int64_t) child - (int64_t) here;
        child_distances[child_dist_count] = dist;
        avg_child_distance += dist;
        child_dist_count += 1;
      }
    }
    fprintf(
      stdout,
      "\nSampled %lu parent distances and %lu child distances.\n",
      parent_dist_count,
      child_dist_count
    );
    fprintf(
      stdout,
      "Average parent/child distances [%lu]: %.2f/%.2f\n",
      seed,
      avg_parent_distance / (double) parent_dist_count,
      avg_child_distance / (double) child_dist_count
    );
    int64_t min_parent_dist = parent_distances[0];
    int64_t max_parent_dist = parent_distances[0];
    int64_t min_child_dist = child_distances[0];
    int64_t max_child_dist = child_distances[0];
    for (id i = 0; i < parent_dist_count; ++i) {
      if (parent_distances[i] < min_parent_dist) {
        min_parent_dist = parent_distances[i];
      }
      if (parent_distances[i] > max_parent_dist) {
        max_parent_dist = parent_distances[i];
      }
    }
    for (id i = 0; i < child_dist_count; ++i) {
      if (child_distances[i] < min_child_dist) {
        min_child_dist = child_distances[i];
      }
      if (child_distances[i] > max_child_dist) {
        max_child_dist = child_distances[i];
      }
    }
    fprintf(
      stdout,
      "Min--max parent/child distances [%lu]: %ld--%ld / %ld--%ld\n\n",
      seed,
      min_parent_dist,
      max_parent_dist,
      min_child_dist,
      max_child_dist
    );
  }
  return 0;
}

int myc_test_select_gnuplot() {
  id n_samples = 100;
  id n_batches = 3;
  id avg_arity = 1;
  id max_arity = 37;
  id seed;
  id parent, child, index;

  char* scriptfile = "test/select/sel-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# sel-data.gpt\n"
    "# gnuplot script for plotting sel-data.dat\n"
    "set term png\n"
    "set output \"sel-data.png\"\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"Parent\"\n"
    "set ylabel \"Child\"\n"
    "datafile = 'sel-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/select/sel-data.dat", "w");
  fprintf(fout, "# Parent child\n");
  id increment = n_samples + n_samples/5;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    seed = myc_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, seed);
    for (child = start; child < start + n_samples; ++child) {
      myc_select_parent_and_index(
        child,
        avg_arity,
        max_arity,
        seed,
        &parent,
        &index
      );
      fprintf(fout, "%lu %lu\n", parent, child);
    }
  }
  fclose(fout);
  return 0;
}

int myc_test_exp_select_gnuplot() {
  id n_samples = 1000;
  id n_batches = 3;
  id avg_arity = 1;
  id max_arity = 37;
  id exp_shape = -0.2;
  id exp_size = 105;
  id seed;
  id parent, child, index;

  char* scriptfile = "test/select/exp-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# exp-data.gpt\n"
    "# gnuplot script for plotting exp-data.dat\n"
    "set term png\n"
    "set output \"exp-data.png\"\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"Parent\"\n"
    "set ylabel \"Child\"\n"
    "datafile = 'exp-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/select/exp-data.dat", "w");
  fprintf(fout, "# Parent child\n");
  for (
    id start = 3298019;
    start < 3298019 + 1930*n_batches;
    start += 1930
  ) {
    seed = myc_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, seed);
    for (child = start; child < start + n_samples; ++child) {
      myc_select_exp_parent_and_index(
        child,
        avg_arity,
        max_arity,
        exp_shape,
        exp_size,
        seed,
        &parent,
        &index
      );
      fprintf(fout, "%lu %lu\n", parent, child);
    }
  }
  fclose(fout);
  return 0;
}
