// vim: syntax=c
/**
 * @file: cohort_tests.cf
 *
 * @description: Unit tests for cohort.h.
 *
 * @author: Peter Mawhorter (pmawhorter@gmail.com)
 */

#include "core/cohort.h"

int test_find_cohort() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    my_cohort = cohort(i, cohort_size, cohort_seed);
    inner = cohort_inner(i, cohort_size, cohort_seed);
    reversed = cohort_outer(my_cohort, inner, cohort_size, cohort_seed);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_find_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    cohort_and_inner(i, cohort_size, cohort_seed, &my_cohort, &inner);
    reversed = cohort_outer(my_cohort, inner, cohort_size, cohort_seed);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_cohort_interleave() {
  id i;
  id cohort_size = 10000;
  id interleaved, reversed;
  for (i = 0; i < cohort_size; ++i) {
    interleaved = cohort_interleave(i, cohort_size);
    reversed = rev_cohort_interleave(interleaved, cohort_size);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort interleave reversibility failed: %lu → %lu → %lu\n",
        i, interleaved, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_cohort_fold() {
  id i;
  id cohort_size = 10000;
  id folded, reversed;
  for (i = 0; i < cohort_size; ++i) {
    folded = cohort_fold(i, cohort_size, 17+i);
    reversed = rev_cohort_fold(folded, cohort_size, 17+i);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort fold reversibility failed: %lu → %lu → %lu\n",
        i, folded, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_cohort_spin() {
  id i;
  id cohort_size = 10000;
  id spun, reversed;
  for (i = 0; i < cohort_size; ++i) {
    spun = cohort_spin(i, cohort_size, 17+i);
    reversed = rev_cohort_spin(spun, cohort_size, 17+i);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort spin reversibility failed: %lu → %lu → %lu\n",
        i, spun, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_cohort_flop() {
  id i;
  id cohort_size = 10000;
  id flopped, reversed;
  for (i = 0; i < cohort_size; ++i) {
    flopped = cohort_flop(i, cohort_size, 17+i);
    reversed = cohort_flop(flopped, cohort_size, 17+i);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort flop reversibility failed: %lu → %lu → %lu\n",
        i, flopped, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_cohort_shuffle() {
  id i;
  id cohort_size = 10000;
  id shuffled, reversed;
  for (i = 0; i < cohort_size; ++i) {
    shuffled = cohort_shuffle(i, cohort_size, 17+i);
    reversed = rev_cohort_shuffle(shuffled, cohort_size, 17+i);
    if (reversed != i) {
      fprintf(
        stderr,
        "Cohort shuffle reversibility failed: %lu → %lu → %lu\n",
        i, shuffled, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_cohort_shuffle_visual() {
  id i;
  id cohort_size = 52;
  id s;
  char results[cohort_size];
  char *original = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  for (i = 0; i < cohort_size; ++i) {
    s = cohort_shuffle(i, cohort_size, 17);
    results[i] = original[s];
    if (s > 51) {
      fprintf(stdout, "I → S    %zu → %zu\n", i, s);
    }
  }
  fprintf(stdout, "Original:         %s\n", original);
  fprintf(stdout, "Shuffle result:   %s\n", results);

  return 0;
}

int test_find_mixed_cohort() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    my_cohort = mixed_cohort(i, cohort_size, cohort_seed);
    inner = mixed_cohort_inner(i, cohort_size, cohort_seed);
    reversed = mixed_cohort_outer(
      my_cohort,
      inner,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Mixed cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_find_mixed_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    mixed_cohort_and_inner(i, cohort_size, cohort_seed, &my_cohort, &inner);
    reversed = mixed_cohort_outer(
      my_cohort,
      inner,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Mixed cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

#define UNLIKELY 102901211
int test_mixed_cohort_visual() {
  id i;
  id cohort_size = 10;
  id cohort_seed = 1;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    for (i = 0; i < length; ++i) {
      mixed_cohort_and_inner(i, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x30 + mxi);
    }
    cohorts[length*cohort_seed + (length-1)] = '\0';
    inners[length*cohort_seed + (length-1)] = '\0';
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int test_find_biased_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id bias = nearest_bias(0.8);
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    biased_cohort_and_inner(
      i,
      bias,
      cohort_size,
      cohort_seed,
      &my_cohort,
      &inner
    );
    reversed = biased_cohort_outer(
      my_cohort,
      inner,
      bias,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Biased cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int test_biased_cohort_visual() {
  id i;
  id cohort_size = 30;
  id cohort_seed = 1;
  id bias;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    bias = nearest_bias(0.25 * cohort_seed);
    for (i = 0; i < length; ++i) {
      biased_cohort_and_inner(i, bias, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x41 + mxi);
    }
    cohorts[length*cohort_seed + (length-1)] = '\0';
    inners[length*cohort_seed + (length-1)] = '\0';
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int test_exp_split_visual() {
  fputc('\n', stdout);
  id sections = 20;
  id section_width = 32;
  for (id i = 0; i < sections; ++i) {
    id result = exp_split(0.05, sections, i, section_width);
    for (id j = 0; j < section_width; ++j) {
      if (j < result) {
        fputc('#', stdout);
      } else {
        fputc('-', stdout);
      }
    }
    fprintf(stdout, " :%02lu", result);
    fputs("    ", stdout);
    result = exp_split(-0.05, sections, i, section_width);
    for (id j = 0; j < section_width; ++j) {
      if (j < result) {
        fputc('#', stdout);
      } else {
        fputc('-', stdout);
      }
    }
    fprintf(stdout, " :%02lu", result);
    fputc('\n', stdout);
  }
  fputc('\n', stdout);
  return 0;
}

int test_exp_cohort_sections_visual() {
  id i;
  id sections = 20;
  id section_width = EXP_SECTION_RESOLUTION;
  id cohort_size = sections * section_width;
  id cohort_seed = 1;
  float shape = -0.05;
  id mxc, mxi;
  size_t lines = cohort_size*2 / section_width;
  char cohorts[lines*section_width+1];
  char inners[lines*section_width+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < cohort_size*2; ++i) {
    exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    inners[i] = (char) (0x41 + (mxi % 26) + ((mxc - first_mxc)%2)*0x20);
  }
  cohorts[lines*section_width] = '\0';
  inners[lines*section_width] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(cohorts[j + section_width*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(inners[j + section_width*i], stdout);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);

  return 0;
}

int test_exp_cohort_visual() {
  id i;
  id cohort_size = 30;
  id cohort_seed = 1;
  float shape;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    if (cohort_seed == 0) {
      shape = 0.05;
    } else if (cohort_seed == 1) {
      shape = -0.05;
    } else {
      shape = 0.5;
    }
    for (i = 0; i < length; ++i) {
      exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x41 + mxi);
    }
    cohorts[length*cohort_seed + (length-1)] = '\0';
    inners[length*cohort_seed + (length-1)] = '\0';
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int test_exp_cohort_inners() {
  id i;
  id sections = 10;
  id section_width = EXP_SECTION_RESOLUTION;
  id cohort_size = sections * section_width;
  id cohort_seed = 752812;
  float shape = 0.05;
  id mxc, mxi;
  id cohorts[cohort_size*3];
  id inners[cohort_size*3];
  id min_mxc = (id) -1;

  // Now fill in the cohorts/inners arrays:
  for (i = 0; i < cohort_size*3; ++i) {
    exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
    if (mxi >= cohort_size) {
      fprintf(stderr, "Error: out-of-range cohort inner %zu!\n", mxi);
    } else {
      cohorts[i] = mxc;
      inners[i] = mxi;
    }
    if (mxc < min_mxc) {
      min_mxc = mxc;
    }
  }

  char observed[cohort_size*4];
  // Zero-out the observed array:
  for (i = 0; i < cohort_size*4; ++i) {
    observed[i] = 0;
  }
  for (i = 0; i < cohort_size*3; ++i) {
    mxc = cohorts[i];
    mxi = inners[i];
    observed[mxi + (cohort_size * (mxc - min_mxc))] += 1;
  }
  fputc('\n', stdout);
  fprintf(stdout, "Cohort size: %zu\n", cohort_size);
  fputc('\n', stdout);
  // Observed counts for min cohort:
  for (mxc = min_mxc; mxc < min_mxc + 4; ++mxc) {
    fprintf(stdout, "Observations of inner indices for cohort %zu:\n\n", mxc);
    for (i = 0; i < cohort_size; ++i) {
      fprintf(stdout, "%d ", observed[i + (mxc - min_mxc)*cohort_size]);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int test_find_exp_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  float shape = 0.25;
  id reversed;
  for (i = 0; i < 391831; i += 12817) {
    exp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_seed,
      &my_cohort,
      &inner
    );
    reversed = exp_cohort_outer(
      my_cohort,
      inner,
      shape,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Exponential cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}
