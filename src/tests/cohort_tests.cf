// vim: syntax=c
/**
 * @file: cohort_tests.cf
 *
 * @description: Unit tests for cohort.h.
 *
 * @author: Peter Mawhorter (pmawhorter@gmail.com)
 */

#include <stdio.h> // for writing files
#include <sys/stat.h> // for chmod

#include "core/cohort.h"

int acy_test_find_cohort() {
  id i, cohort_size;
  id my_cohort, inner; 
  id reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < 391029831; i += 290320) {
      my_cohort = acy_cohort(i, cohort_size);
      inner = acy_cohort_inner(i, cohort_size);
      reversed = acy_cohort_outer(my_cohort, inner, cohort_size);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort reversibility failed: %lu → %lu/%lu → %lu\n",
          i, my_cohort, inner, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_find_cohort_and_inner() {
  id i, cohort_size;
  id my_cohort, inner; 
  id reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < 391029831; i += 290320) {
      acy_cohort_and_inner(i, cohort_size, &my_cohort, &inner);
      reversed = acy_cohort_outer(my_cohort, inner, cohort_size);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort reversibility failed: %lu → %lu/%lu → %lu\n",
          i, my_cohort, inner, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_interleave() {
  id i, cohort_size;
  id interleaved, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      interleaved = acy_cohort_interleave(i, cohort_size);
      reversed = acy_rev_cohort_interleave(interleaved, cohort_size);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort interleave reversibility failed: %lu → %lu → %lu\n",
          i, interleaved, reversed
        );
        return (int) i+1;
      } else if (interleaved >= cohort_size) {
        fprintf(
          stderr,
          "Cohort interleave bounds check failed: %lu → %lu (>= %lu)\n",
          i, interleaved, cohort_size
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_fold() {
  id i, cohort_size;
  id folded, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      folded = acy_cohort_fold(i, cohort_size, 17+i);
      reversed = acy_rev_cohort_fold(folded, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort fold reversibility failed: %lu → %lu → %lu\n",
          i, folded, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_spin() {
  id i, cohort_size;
  id spun, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      spun = acy_cohort_spin(i, cohort_size, 17+i);
      reversed = acy_rev_cohort_spin(spun, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort spin reversibility failed: %lu → %lu → %lu\n",
          i, spun, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_flop() {
  id i, cohort_size;
  id flopped, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      flopped = acy_cohort_flop(i, cohort_size, 17+i);
      reversed = acy_cohort_flop(flopped, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort flop reversibility failed: %lu → %lu → %lu\n",
          i, flopped, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_mix() {
  id i, cohort_size;
  id mixed, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      mixed = acy_cohort_mix(i, cohort_size, 17+i);
      reversed = acy_rev_cohort_mix(mixed, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort mix reversibility failed [%lu]: %lu → %lu → %lu\n",
          cohort_size, i, mixed, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_spread() {
  id i, cohort_size;
  id spread, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      spread = acy_cohort_spread(i, cohort_size, 1182453 + cohort_size);
      reversed = acy_rev_cohort_spread(
        spread,
        cohort_size,
        1182453 + cohort_size
      );
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort spread reversibility failed [%lu]: %lu → %lu → %lu\n",
          cohort_size, i, spread, reversed
        );
        return (int) i+1;
      } else if (spread >= cohort_size) {
        fprintf(
          stderr,
          "Cohort spread out-of-bounds [%lu]: %lu → %lu\n",
          cohort_size, i, spread
        );
      }
    }
  }

  return 0;
}

int acy_test_cohort_upend() {
  id i, cohort_size;
  id upended, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      upended = acy_cohort_upend(i, cohort_size, 17+i);
      reversed = acy_cohort_upend(upended, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort upend reversibility failed [%lu]: %lu → %lu → %lu\n",
          cohort_size, i, upended, reversed
        );
        return (int) i+1;
      } else if (upended >= cohort_size) {
        fprintf(
          stderr,
          "Cohort upend out-of-bounds [%lu]: %lu → %lu\n",
          cohort_size, i, upended
        );
      }
    }
  }

  return 0;
}

int acy_test_cohort_shuffle() {
  id i, cohort_size;
  id shuffled, reversed;
  for (cohort_size = 2; cohort_size < 1000; ++cohort_size) {
    for (i = 0; i < cohort_size; ++i) {
      shuffled = acy_cohort_shuffle(i, cohort_size, 17+i);
      reversed = acy_rev_cohort_shuffle(shuffled, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort shuffle reversibility failed: %lu → %lu → %lu (size %lu)\n",
          i, shuffled, reversed, cohort_size
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_shuffle_visual() {
  id i;
  id cohort_size = 52;
  id s;
  char results[cohort_size+1];
  char *original = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  for (i = 0; i < cohort_size; ++i) {
    s = acy_cohort_shuffle(i, cohort_size, 17);
    results[i] = original[s];
    if (s >= cohort_size) {
      fprintf(
        stderr,
        "Error: Invalid shuffled value:\nI → S    %zu → %zu\n",
        i, s
      );
      return i+1;
    }
  }
  results[cohort_size] = '\0';
  fprintf(stdout, "\nOriginal:         %s\n", original);
  fprintf(stdout, "Shuffle result:   %s\n\n", results);

  return 0;
}

int acy_test_cohort_shuffle_visual_list() {
  id i;
  id cohort_size = 18201821;
  id sample_size = 12;
  id s;
  fprintf(stdout, "\nShuffle sample (cohort size is %lu):\n", cohort_size);
  for (i = cohort_size/2; i < cohort_size/2 + sample_size; ++i) {
    s = acy_cohort_shuffle(i, cohort_size, 84398384391);
    if (s >= cohort_size) {
      fprintf(
        stderr,
        "Error: Invalid shuffled value:\nI → S    %zu → %zu\n",
        i, s
      );
      return i+1;
    }
    fprintf(stdout, "  %zu → %zu\n", i, s);
  }
  fprintf(stdout, "\n");

  cohort_size = 300000000000;
  fprintf(stdout, "\nShuffle sample (cohort size is %lu):\n", cohort_size);
  for (i = cohort_size/2; i < cohort_size/2 + sample_size; ++i) {
    s = acy_cohort_shuffle(i, cohort_size, 1654686134);
    if (s >= cohort_size) {
      fprintf(
        stderr,
        "Error: Invalid shuffled value:\nI → S    %zu → %zu\n",
        i, s
      );
      return i+1;
    }
    fprintf(stdout, "  %zu → %zu\n", i, s);
  }
  fprintf(stdout, "\n");

  return 0;
}

int acy_test_find_mixed_cohort() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    my_cohort = acy_mixed_cohort(i, cohort_size, cohort_seed);
    inner = acy_mixed_cohort_inner(i, cohort_size, cohort_seed);
    reversed = acy_mixed_cohort_outer(
      my_cohort,
      inner,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Mixed cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int acy_test_find_mixed_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    acy_mixed_cohort_and_inner(i, cohort_size, cohort_seed, &my_cohort, &inner);
    reversed = acy_mixed_cohort_outer(
      my_cohort,
      inner,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Mixed cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

#define UNLIKELY 102901211
int acy_test_mixed_cohort_visual() {
  id i;
  id cohort_size = 10;
  id cohort_seed = 1;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    for (i = 0; i < length; ++i) {
      acy_mixed_cohort_and_inner(i, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x30 + mxi);
    }
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int acy_test_find_biased_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id bias = acy_nearest_bias(0.8);
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    acy_biased_cohort_and_inner(
      i,
      bias,
      cohort_size,
      cohort_seed,
      &my_cohort,
      &inner
    );
    reversed = acy_biased_cohort_outer(
      my_cohort,
      inner,
      bias,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Biased cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int acy_test_biased_cohort_visual() {
  id i;
  id cohort_size = 30;
  id cohort_seed = 1;
  id bias;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    bias = acy_nearest_bias(0.25 * cohort_seed);
    for (i = 0; i < length; ++i) {
      acy_biased_cohort_and_inner(
        i,
        bias,
        cohort_size,
        cohort_seed,
        &mxc,
        &mxi
      );
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x41 + mxi);
    }
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int acy_test_exp_split_visual() {
  fputc('\n', stdout);
  id sections = 20;
  id section_width = 32;
  for (id i = 0; i < sections; ++i) {
    id result = acy_exp_split(10, sections, section_width, i);
    for (id j = 0; j < section_width; ++j) {
      if (j < result) {
        fputc('#', stdout);
      } else {
        fputc('-', stdout);
      }
    }
    fprintf(stdout, " :%02lu", result);
    fputs("    ", stdout);
    result = acy_exp_split(-10, sections, section_width, i);
    for (id j = 0; j < section_width; ++j) {
      if (j < result) {
        fputc('#', stdout);
      } else {
        fputc('-', stdout);
      }
    }
    fprintf(stdout, " :%02lu", result);
    fputc('\n', stdout);
  }
  fputc('\n', stdout);
  return 0;
}

int acy_test_multiexp_split_visual() {
  fputc('\n', stdout);
  id sections = 20;
  id section_width = 32;
  id n_layers = 4;
  for (id i = sections; i < 2*sections; ++i) {
    fputs("    ", stdout);
    for (id j = 0; j < section_width; ++j) {
      id layer = acy_multiexp_get_layer(
        i,
        j,
        50,
        sections,
        section_width,
        n_layers
      );
      fputc(0x30 + layer, stdout);
    }
    fputs("    ", stdout);
    for (id j = 0; j < section_width; ++j) {
      id layer = acy_multiexp_get_layer(
        i,
        j,
        -50,
        sections,
        section_width,
        n_layers
      );
      fputc(0x30 + layer, stdout);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);
  return 0;
}

int acy_test_multiexp_split_visual_extended() {
  fputc('\n', stdout);
  id sections = 20;
  id section_width = 32;
  id n_layers = 4;
  for (id i = 0; i < 3*sections; ++i) {
    id cohort = i / sections;
    id inner = sections + i % sections;
    fputs("    ", stdout);
    for (id j = 0; j < section_width; ++j) {
      id layer = acy_multiexp_get_layer(
        inner,
        j,
        50,
        sections,
        section_width,
        n_layers
      );
      id adjusted = layer + cohort * n_layers;
      fputc(0x30 + adjusted, stdout);
    }
    fputs("    ", stdout);
    for (id j = 0; j < section_width; ++j) {
      id layer = acy_multiexp_get_layer(
        inner,
        j,
        -50,
        sections,
        section_width,
        n_layers
      );
      id adjusted = cohort * n_layers - layer;
      fputc(0x30 + adjusted, stdout);
    }
    fputc('\n', stdout);
    if (i % sections == sections - 1) {
      fputc('\n', stdout);
    }
  }
  fputc('\n', stdout);
  return 0;
}

int acy_test_exp_cohort_sections_visual() {
  id i;
  id sections = 20;
  id section_width = 32;
  id cohort_size = sections * section_width;
  id cohort_seed = 1;
  float shape = -50;
  id mxc, mxi;
  size_t lines = cohort_size*2 / section_width;
  char cohorts[lines*section_width+1];
  char inners[lines*section_width+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < cohort_size*2; ++i) {
    acy_exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    if (cohorts[i] == '1') {
      inners[i] = (char) (0x41 + (mxi % 26));
    } else {
      inners[i] = '-';
    }
  }
  cohorts[lines*section_width] = '\0';
  inners[lines*section_width] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(cohorts[j + section_width*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(inners[j + section_width*i], stdout);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);

  return 0;
}

int acy_test_exp_cohort_visual() {
  id i;
  id cohort_size = 30;
  id cohort_seed = 1;
  float shape;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    if (cohort_seed == 0) {
      shape = 50;
    } else if (cohort_seed == 1) {
      shape = -50;
    } else {
      shape = 2;
    }
    for (i = 0; i < length; ++i) {
      acy_exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x41 + mxi);
    }
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int acy_test_exp_cohort_inners() {
  id i;
  id sections = 10;
  id section_width = 32;
  id cohort_size = sections * section_width;
  id cohort_seed = 752812;
  float shape = 50;
  id mxc, mxi;
  id cohorts[cohort_size*3];
  id inners[cohort_size*3];
  id min_mxc = (id) -1;

  // Now fill in the cohorts/inners arrays:
  for (i = 0; i < cohort_size*3; ++i) {
    acy_exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
    if (mxi >= cohort_size) {
      fprintf(stderr, "Error: out-of-range cohort inner %zu!\n", mxi);
    } else {
      cohorts[i] = mxc;
      inners[i] = mxi;
    }
    if (mxc < min_mxc) {
      min_mxc = mxc;
    }
  }

  char observed[cohort_size*4];
  // Zero-out the observed array:
  for (i = 0; i < cohort_size*4; ++i) {
    observed[i] = 0;
  }
  for (i = 0; i < cohort_size*3; ++i) {
    mxc = cohorts[i];
    mxi = inners[i];
    observed[mxi + (cohort_size * (mxc - min_mxc))] += 1;
  }
  fputc('\n', stdout);
  fprintf(stdout, "Cohort size: %zu\n", cohort_size);
  fputc('\n', stdout);
  // Observed counts for min cohort:
  for (mxc = min_mxc; mxc < min_mxc + 4; ++mxc) {
    fprintf(stdout, "Observations of inner indices for cohort %zu:\n\n", mxc);
    for (i = 0; i < cohort_size; ++i) {
      fprintf(stdout, "%d ", observed[i + (mxc - min_mxc)*cohort_size]);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int acy_test_find_exp_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  float shape = 5;
  id reversed;
  for (i = 0; i < 391831; i += 12817) {
    acy_exp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_seed,
      &my_cohort,
      &inner
    );
    reversed = acy_exp_cohort_outer(
      my_cohort,
      inner,
      shape,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Exponential cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int acy_test_multiexp_layer_consistency_visual() {
  id section;
  id cohort_size = 10073;
  id n_layers = 8;
  id section_width = 52;
  id section_count = cohort_size / section_width;
  id layer_width = section_count / n_layers;
  // TODO: Get this working for negative shapes?
  float shape = 60;
  id last_split;
  id show_sections = 30;
  fprintf(
    stdout,
    "\n     Section width: %lu   Section count: %lu   Layer width: %lu\n     ", 
    section_width,
    section_count,
    layer_width
  );
  for (id i = 0; i < section_width; ++i) {
    fputc('=', stdout);
  }
  fputc('\n', stdout);
  for (
    section = section_count-2;
    section < section_count-2 + show_sections;
    ++section
  ) {
    fprintf(stdout, "%-3lu: ", section);
    last_split = 0;
    id written = 0;
    for (id layer = 0; layer < n_layers*2+1; ++layer) {
      id layer_origin_section = layer_width * layer;
      id split = acy_multiexp_split(
        shape,
        section_count,
        section_width,
        section,
        layer,
        n_layers
      );
      if (split < last_split) {
        fputc('X', stdout);
        written += 1;
        for (id i = written; i < section_width+1; ++i) {
          fputc(' ', stdout);
        }
        break;
      }
      for (id i = 0; i < split - last_split; ++i) {
        if (section >= layer_origin_section) {
          fputc(0x30 + layer, stdout);
        } else {
          fputc(0x60 + layer, stdout);
        }
        written += 1;
      }
      last_split = split;
    }
    fprintf(stdout, " [");
    for (id layer = 0; layer < n_layers*2+1; ++layer) {
      id layer_origin_section = layer_width * layer;
      if (
        section >= layer_origin_section - layer_width
     && section < layer_origin_section + section_count
      ) {
        fputc(0x30 + layer, stdout);
      } else {
        fputc('_', stdout);
      }
    }
    fprintf(stdout, "]\n");
  }
  fprintf(stdout, "     ");
  for (id i = 0; i < section_width; ++i) {
    fputc('=', stdout);
  }
  fputc('\n', stdout);
  fputc('\n', stdout);

  return 0;
}

/*
 * TODO: Get rid of this?
int acy_test_find_multiexp_layer_and_inner() {
  id i;
  id my_layer, inner; 
  id cohort_size = 10073;
  id cohort_seed = 5528810291;
  id cohort_layers = 8;
  id section_width = 64;
  id section_count = cohort_size / section_width;
  float shape = 60;
  id reversed;
  for (i = 8281942431; i < 8281942431 + 465134; i += 3146) {
    id within_cohort = i % cohort_size;
    acy_multiexp_layer_and_inner(
      within_cohort,
      cohort_size,
      shape,
      section_count,
      section_width,
      cohort_layers,
      cohort_seed,
      &my_layer,
      &inner
    );
    if (inner >= cohort_size) {
      fprintf(
        stderr,
        "Multi-exponential layer index out-of-bounds: %lu → %lu/%lu [%lu]\n",
        within_cohort, my_layer, inner, cohort_size
      );
      return (int) i+1;
    }
    reversed = acy_multiexp_layer_outer(
      my_layer,
      inner,
      cohort_size,
      shape,
      section_count,
      section_width,
      cohort_layers,
      cohort_seed
    );
    if (reversed != within_cohort) {
      fprintf(
        stderr,
        "Multi-exponential layer reversibility failed: %lu → %lu/%lu → %lu\n",
        within_cohort, my_layer, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}
*/

int acy_test_find_multiexp_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id cohort_layers = 8;
  float shape = 5;
  id reversed;
  for (i = 89898128; i < 89898128 + 3921831; i += 12817) {
    acy_multiexp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed,
      &my_cohort,
      &inner
    );
    if (inner >= cohort_size) {
      fprintf(
        stderr,
        "Multi-exponential cohort index out-of-bounds: %lu → %lu/%lu [%lu]\n",
        i, my_cohort, inner, cohort_size
      );
      return (int) i+1;
    }
    reversed = acy_multiexp_cohort_outer(
      my_cohort,
      inner,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Multi-exponential cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int acy_test_multiexp_cohort_sections_visual() {
  id i;
  id sections = 20;
  id section_width = 32;
  id cohort_size = sections * section_width;
  id cohort_layers = 4;
  id cohort_seed = 1;
  // TODO: Get this test working with a negative shape!
  float shape = 50;
  id mxc, mxi;
  size_t lines = cohort_size*2 / section_width;
  char cohorts[lines*section_width+1];
  char inners[lines*section_width+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < cohort_size*2; ++i) {
    acy_multiexp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed,
      &mxc,
      &mxi
    );
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    if (cohorts[i] == '1') {
      inners[i] = (char) (0x41 + (mxi % 26));
    } else {
      inners[i] = '-';
    }
  }
  cohorts[lines*section_width] = '\0';
  inners[lines*section_width] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(cohorts[j + section_width*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(inners[j + section_width*i], stdout);
    }
    fputc('\n', stdout);
    if (i % sections == sections - 1) {
      fputc('\n', stdout);
    }
  }
  fputc('\n', stdout);

  return 0;
}

int acy_test_count_multiexp_cohorts() {
  id i;
  id cohort_size = 1037;
  id cohort_layers = 4;
  id cohort_seed = 10920192831;
  float shape = 50;
  id mxc, mxi;
  id possible_layers = (cohort_layers * 3 + 1);
  id cohort_counts[possible_layers];
  id inner_counts[cohort_size * possible_layers];
  // zero out stuff:
  for (i = 0; i < possible_layers; ++i) {
    cohort_counts[i] = 0;
    for (id j = 0; j < cohort_size; ++j) {
      inner_counts[i*cohort_size + j] = 0;
    }
  }
  // count cohorts & indices seen across two cohorts (should fully capture
  // cohorts 5/6/7 → 1/2/3 when using 4 layers)
  for (i = 0; i < cohort_size*2; ++i) {
    acy_multiexp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed,
      &mxc,
      &mxi
    );
    if (mxc >= possible_layers) {
      fprintf(
        stderr,
        "\nMultiexp cohort out-of-bounds while counting: %lu/%lu\n",
        mxc,
        possible_layers
      );
      return i+1;
    }
    cohort_counts[mxc] += 1;
    if (mxi >= cohort_size) {
      fprintf(
        stderr,
        "\nMultiexp inner out-of-bounds while counting: %lu/%lu\n",
        mxi,
        cohort_size
      );
      continue;
      return i+1;
    }
    inner_counts[mxc * cohort_size + mxi] += 1;
  }
  // print totals:
  fprintf(stdout, "\nMultiexponential cohort observations:\n");
  for (i = 0; i < possible_layers; ++i) {
    fprintf(stdout, " %3lu", i);
  }
  fputc('\n', stdout);
  for (i = 0; i < possible_layers; ++i) {
    fprintf(stdout, " %3lu", cohort_counts[i]);
  }
  fputc('\n', stdout);

  fprintf(stdout, "\nMultiexponential inner observations:\n   ");
  for (i = 0; i < (80/3)-1; ++i) {
    fprintf(stdout, " %2lu", i);
  }
  fputc('\n', stdout);
  for (i = 0; i < possible_layers; ++i) {
    fprintf(stdout, "%-2lu:", i);
    for (id j = 0; j < (80/3)-1; ++j) {
      fprintf(stdout, " %2lu", inner_counts[i*cohort_size+j]);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);
  // limits on totals:
  for (i = 0; i < possible_layers; ++i) {
    /*
     * TODO: Limits on cohort counts?
    if (cohort_counts[i] != cohort_size) {
      fprintf(
        stderr, 
        "\nMultiexp cohort counting error: cohort %lu found %lu/%lu times.\n",
        i, cohort_counts[i], cohort_size
      );
      return i+1;
    }
    */
    for (id j = 0; j < cohort_size; ++j) {
      if (inner_counts[i*cohort_size + j] > 1) {
        fprintf(
          stderr, 
          "\nMultiexp inner over-count error: "
            "inner %lu in cohort %lu found %lu/1 times.\n",
          j, i, inner_counts[i*cohort_size + j]
        );
        return i+1;
      }
    }
  }

  return 0;
}

int acy_test_cohort_shuffle_gnuplot() {
  id n_samples = 1000;
  id n_batches = 3;
  id cohort_size = 1000;
  id seed;
  id index, shuffled;

  char* scriptfile = "test/cohort/shuffle-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# shuffle-data.gpt\n"
    "# gnuplot script for plotting shuffle-data.dat\n"
    "set term png\n"
    "set output \"shuffle-data.png\"\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"Parent\"\n"
    "set ylabel \"Child\"\n"
    "datafile = 'shuffle-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/shuffle-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples + n_samples/5;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    seed = acy_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, seed);
    for (index = start; index < start + n_samples; ++index) {
      shuffled = acy_cohort_shuffle(index, cohort_size, seed);
      fprintf(fout, "%lu %lu\n", index, shuffled);
    }
  }
  fclose(fout);
  return 0;
}

int acy_test_exp_cohort_gnuplot() {
  id n_batches = 3;
  //id cohort_size = 100;
  id cohort_size = 37*105;
  id n_samples = cohort_size;
  float cohort_shape = 80;
  id seed;
  id outer, inner, cohort;

  char* scriptfile = "test/cohort/exp-cohort-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# exp-cohort-data.gpt\n"
    "# gnuplot script for plotting exp-cohort-data.dat\n"
    "set term png\n"
    "set output \"exp-cohort-data.png\"\n"
    "set title \"Exponential Cohorts\"\n"
    "set key off\n"
    "set xlabel \"Outer\"\n"
    "set ylabel \"Relative Inner\"\n"
    "datafile = 'exp-cohort-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/exp-cohort-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples;
  id outers[n_samples*n_batches];
  id inners[n_samples*n_batches];
  id cohorts[n_samples*n_batches];
  id batch = 0;
  id min_cohort = 0 - 1;
  id max_cohort = 0;
  id idx = 0;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    idx = n_samples*batch;
    seed = acy_prng(start, start + 66489419814);
    for (outer = start; outer < start + n_samples; ++outer) {
      acy_exp_cohort_and_inner(
        outer - (cohort_size*2),
        cohort_shape,
        cohort_size,
        seed,
        &cohort,
        &inner
      );
      outers[idx] = outer;
      cohorts[idx] = cohort;
      inners[idx] = inner;
      if (cohort < min_cohort) { min_cohort = cohort; }
      if (cohort > max_cohort) { max_cohort = cohort; }
      idx += 1;
    }
    batch += 1;
  }
  for (id coh = min_cohort; coh < max_cohort+1; ++coh) {
    fprintf(fout, "\n\n\"Inners for cohort %lu (batch %lu):\"\n", coh, batch);
    for (idx = 0; idx < n_samples*n_batches; ++idx) {
      if (cohorts[idx] == coh) {
        fprintf(
          fout,
          "%lu %lu\n",
          outers[idx],
          inners[idx] + (coh - min_cohort) * cohort_size
        );
      }
    }
  }
  fclose(fout);
  return 0;
}

int acy_test_multiexp_cohort_gnuplot() {
  id n_batches = 3;
  id cohort_layers = 4;
  id cohort_size = 107 * cohort_layers;
  id n_samples = cohort_size;
  float cohort_shape = 80;
  id seed;
  id outer, inner, cohort;

  char* scriptfile = "test/cohort/multiexp-cohort-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multiexp-cohort-data.gpt\n"
    "# gnuplot script for plotting multiexp-cohort-data.dat\n"
    "set term png\n"
    "set output \"multiexp-cohort-data.png\"\n"
    "set title \"Multi-Exponential Cohorts\"\n"
    "set key off\n"
    "set xlabel \"Outer\"\n"
    "set ylabel \"Relative Inner\"\n"
    "datafile = 'multiexp-cohort-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multiexp-cohort-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples;
  id outers[n_samples*n_batches];
  id inners[n_samples*n_batches];
  id cohorts[n_samples*n_batches];
  id batch = 0;
  id min_cohort = 0 - 1;
  id max_cohort = 0;
  id idx = 0;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    idx = n_samples*batch;
    seed = acy_prng(start, start + 66489419814);
    for (outer = start; outer < start + n_samples; ++outer) {
      acy_multiexp_cohort_and_inner(
        outer,
        cohort_shape,
        cohort_size,
        cohort_layers,
        seed,
        &cohort,
        &inner
      );
      outers[idx] = outer;
      cohorts[idx] = cohort;
      inners[idx] = inner;
      if (cohort < min_cohort) { min_cohort = cohort; }
      if (cohort > max_cohort) { max_cohort = cohort; }
      idx += 1;
    }
    batch += 1;
  }
  for (id coh = min_cohort; coh < max_cohort+1; ++coh) {
    fprintf(fout, "\n\n\"Inners for cohort %lu (batch %lu):\"\n", coh, batch);
    for (idx = 0; idx < n_samples*n_batches; ++idx) {
      if (cohorts[idx] == coh) {
        fprintf(
          fout,
          "%lu %lu\n",
          outers[idx],
          inners[idx] + (coh - min_cohort) * cohort_size
        );
      }
    }
  }
  fclose(fout);
  return 0;
}

int acy_test_multiexp_generations_gnuplot() {
  id n_samples = 100;
  id n_batches = 4;
  double cohort_shape = 30.0;
  id cohort_size = 1000;
  id stride = cohort_size / n_samples;
  id cohort_layers = 4;
  id cohort_seed;
  id parent, cohort, child;

  char* scriptfile = "test/cohort/multiexp-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multiexp-data.gpt\n"
    "# gnuplot script for plotting multiexp-data.dat\n"
    "set term png\n"
    "set output \"multiexp-data.png\"\n"
    "set key off\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"ID\"\n"
    "set ylabel \"Generation\"\n"
    "set yrange [0:3]\n"
    "datafile = 'multiexp-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multiexp-data.dat", "w");
  fprintf(fout, "# ID Generation\n");
  id increment = cohort_size * 2;
  for (
    id start = 10000;
    start < 10000 + increment * n_batches;
    start += increment
  ) {
    cohort_seed = acy_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, cohort_seed);
    for (parent = start; parent < start + cohort_size; parent += stride) {
      acy_multiexp_cohort_and_inner(
        parent,
        cohort_shape,
        cohort_size,
        cohort_layers,
        cohort_seed,
        &cohort,
        &child
      );
      fprintf(fout, "%lu 2\n", parent);
      fprintf(fout, "%lu 1.5\n", cohort * cohort_size / cohort_layers + child);
      fprintf(fout, "%lu 1\n", cohort * cohort_size + child);
    }
  }
  fclose(fout);
  return 0;
}


int acy_test_find_multipoly_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_shape = 3;
  id cohort_seed = 1728;

  id cohort_size_base;

  acy_multipoly_nearest_cohort_size(
    cohort_shape,
    cohort_size,
    &cohort_size,
    &cohort_size_base
  );

  id reversed;
  for (i = 89898128; i < 89898128 + 3921831; i += 12817) {
    acy_multipoly_cohort_and_inner(
      i,
      cohort_size_base,
      cohort_shape,
      cohort_seed,
      &my_cohort,
      &inner
    );
    if (inner >= cohort_size) {
      fprintf(
        stderr,
        "Multi-polynomial cohort index out-of-bounds: %lu → %lu/%lu [%lu]\n",
        i, my_cohort, inner, cohort_size
      );
      return (int) i+1;
    }
    reversed = acy_multipoly_cohort_outer(
      my_cohort,
      inner,
      cohort_size_base,
      cohort_shape,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Multi-polynomial cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int acy_test_multipoly_cohort_sections_visual() {
  id i;
  id cohort_size = 38;
  id cohort_shape = 3;
  id cohort_seed = 1728;

  id cohort_size_base;

  acy_multipoly_smaller_cohort_size(
    cohort_shape,
    cohort_size,
    &cohort_size,
    &cohort_size_base
  );

  id mxc, mxi;
  size_t lines = cohort_size_base * 2;
  char cohorts[lines*cohort_size+1];
  char inners[lines*cohort_size+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < lines*cohort_size; ++i) {
    acy_multipoly_cohort_and_inner(
      i,
      cohort_size_base,
      cohort_shape,
      cohort_seed,
      &mxc,
      &mxi
    );
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    if (cohorts[i] == '1') {
      inners[i] = (char) (0x41 + (mxi % 26));
    } else {
      inners[i] = '-';
    }
  }
  cohorts[lines*cohort_size] = '\0';
  inners[lines*cohort_size] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < cohort_size; ++j) {
      fputc(cohorts[j + cohort_size*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < cohort_size; ++j) {
      fputc(inners[j + cohort_size*i], stdout);
    }
    fputc('\n', stdout);
    if (i % cohort_size == cohort_size - 1) {
      fputc('\n', stdout);
    }
  }
  fputc('\n', stdout);

  return 0;
}

int acy_test_count_multipoly_cohorts() {
  id i;
  id cohort_size;
  id cohort_shape;
  id cohort_size_base;

  id cohort_seed = 10920192831;

  id target_sizes[]  = { 24, 48, 1025, 9472, 30458 };
  id target_shapes[] = {  2,  5,    3,    8,    32 };

  id target;
  for (target = 0; target < 5; ++target) {
    cohort_size = target_sizes[target];
    cohort_shape = target_shapes[target];

    acy_multipoly_smaller_cohort_size(
      cohort_shape,
      cohort_size,
      &cohort_size,
      &cohort_size_base
    );

    id sample_start = cohort_size * cohort_size_base * 300;

    fprintf(
      stdout,
      "\nMulipoly cohort size/base: %lu/%lu\n",
      cohort_size,
      cohort_size_base
    );

    // count cohorts & indices seen across two super-cohorts
    id mxc, mxi;
    id explore = cohort_size * cohort_size_base * 2;
    id possible_cohorts = cohort_size_base * 3 + 1; // a bit liberal

    id* cohort_counts = (id*) malloc(
      sizeof(id) * possible_cohorts
    );
    id* inner_counts = (id*) malloc(
      sizeof(id) * cohort_size * possible_cohorts
    );

    // zero out stuff:
    for (i = 0; i < possible_cohorts; ++i) {
      cohort_counts[i] = 0;
      for (id j = 0; j < cohort_size; ++j) {
        inner_counts[i*cohort_size + j] = 0;
      }
    }

    // counting occurrences:
    id first_mxc = UNLIKELY;
    for (i = sample_start; i < sample_start + explore; ++i) {
      acy_multipoly_cohort_and_inner(
        i,
        cohort_size_base,
        cohort_shape,
        cohort_seed,
        &mxc,
        &mxi
      );
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      mxc -= first_mxc;
      if (mxc >= possible_cohorts) {
        fprintf(
          stderr,
          "\nMulipoly cohort out-of-bounds while counting: %lu/%lu\n",
          mxc,
          possible_cohorts
        );
        return i+1;
      }
      cohort_counts[mxc] += 1;
      if (mxi >= cohort_size) {
        fprintf(
          stderr,
          "\nMulipoly inner out-of-bounds while counting: %lu/%lu\n",
          mxi,
          cohort_size
        );
        continue;
        return i+1;
      }
      inner_counts[mxc * cohort_size + mxi] += 1;
    }
    // print totals for first few targets:
    if (target < 2) {
      fprintf(stdout, "\nMultipolynomial cohort observations:\n");
      for (i = 0; i < possible_cohorts; ++i) {
        fprintf(stdout, " %3lu", i);
      }
      fputc('\n', stdout);
      for (i = 0; i < possible_cohorts; ++i) {
        fprintf(stdout, " %3lu", cohort_counts[i]);
      }
      fputc('\n', stdout);

      fprintf(stdout, "\nMultipolynomial inner observations:\n   ");
      id width = (80/3)-1;
      if (width > cohort_size) {
        width = cohort_size;
      }
      for (i = 0; i < width; ++i) {
        fprintf(stdout, " %2lu", i);
      }
      fputc('\n', stdout);
      for (i = 0; i < possible_cohorts; ++i) {
        fprintf(stdout, "%-2lu", i);
        if (cohort_counts[i] == cohort_size) {
          fputc('~', stdout);
        } else {
          fputc(':', stdout);
        }
        for (id j = 0; j < width; ++j) {
          fprintf(stdout, " %2lu", inner_counts[i*cohort_size+j]);
        }
        fputc('\n', stdout);
      }
    }
    fputc('\n', stdout);
    // limits on totals:
    for (i = 0; i < possible_cohorts; ++i) {
      if (
      i >= cohort_size_base - 1
   && i < 2*cohort_size_base - 1
   && cohort_counts[i] != cohort_size
      ) {
        fprintf(
          stderr, 
          "\nMulipoly cohort counting error: cohort %lu found %lu/%lu times.\n",
          i, cohort_counts[i], cohort_size
        );
        return i+1;
      }
      for (id j = 0; j < cohort_size; ++j) {
        if (inner_counts[i*cohort_size + j] > 1) {
          fprintf(
            stderr, 
            "\nMulipoly inner over-count error: "
              "inner %lu in cohort %lu found %lu/1 times.\n",
            j, i, inner_counts[i*cohort_size + j]
          );
          return i+1;
        }
      }
    }

    free(cohort_counts);
    free(inner_counts);
  }

  return 0;
}

int acy_test_multipoly_cohort_gnuplot() {
  id cohort_size = 200;
  id cohort_shape = 16;

  id cohort_size_base;

  acy_multipoly_nearest_cohort_size(
    cohort_shape,
    cohort_size,
    &cohort_size,
    &cohort_size_base
  );

  id n_batches = 2 * cohort_size_base;

  id n_samples = cohort_size;

  id seed;
  id outer, inner, cohort;

  char* scriptfile = "test/cohort/multipoly-cohort-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multipoly-cohort-data.gpt\n"
    "# gnuplot script for plotting multipoly-cohort-data.dat\n"
    "set term png\n"
    "set output \"multipoly-cohort-data.png\"\n"
    "set title \"Multi-Polynomial Cohorts\"\n"
    "set key off\n"
    "set xlabel \"Relative Outer\"\n"
    "set ylabel \"Relative Inner\"\n"
    "datafile = 'multipoly-cohort-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multipoly-cohort-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples;
  id outers[n_samples*n_batches];
  id inners[n_samples*n_batches];
  id cohorts[n_samples*n_batches];
  id batch = 0;
  id min_cohort = 0 - 1;
  id max_cohort = 0;
  id idx = 0;
  id beginning = 3298019;
  for (
    id start = beginning;
    start < beginning + increment * n_batches;
    start += increment
  ) {
    idx = n_samples*batch;
    seed = acy_prng(start, start + 66489419814);
    for (outer = start; outer < start + n_samples; ++outer) {
      acy_multipoly_cohort_and_inner(
        outer,
        cohort_size_base,
        cohort_shape,
        seed,
        &cohort,
        &inner
      );
      outers[idx] = outer - beginning;
      cohorts[idx] = cohort;
      inners[idx] = inner;
      if (cohort < min_cohort) { min_cohort = cohort; }
      if (cohort > max_cohort) { max_cohort = cohort; }
      idx += 1;
    }
    batch += 1;
  }
  for (id coh = min_cohort; coh < max_cohort+1; ++coh) {
    fprintf(fout, "\n\n\"Inners for cohort %lu:\"\n", coh);
    for (idx = 0; idx < n_samples*n_batches; ++idx) {
      if (cohorts[idx] == coh) {
        fprintf(
          fout,
          "%lu %lu\n",
          outers[idx],
          // coh - min_cohort
          // inners[idx]
          inners[idx] + (coh - min_cohort) * cohort_size
        );
      }
    }
  }
  fclose(fout);
  return 0;
}

int acy_test_multipoly_generations_gnuplot() {
  id n_batches = 4;
  id stride = 10;

  id cohort_size = 1000;
  id cohort_shape = 4;

  id cohort_size_base;

  acy_multipoly_nearest_cohort_size(
    cohort_shape,
    cohort_size,
    &cohort_size,
    &cohort_size_base
  );

  id seed;
  id parent, cohort, child;

  char* scriptfile = "test/cohort/multipoly-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multipoly-data.gpt\n"
    "# gnuplot script for plotting multipoly-data.dat\n"
    "set term png\n"
    "set output \"multipoly-data.png\"\n"
    "set key off\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"ID\"\n"
    "set ylabel \"Generation\"\n"
    "set yrange [0:3]\n"
    "datafile = 'multipoly-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multipoly-data.dat", "w");
  fprintf(fout, "# ID Generation\n");
  id increment = cohort_size * 2;
  for (
    id start = 10000;
    start < 10000 + increment * n_batches;
    start += increment
  ) {
    seed = acy_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, seed);
    for (parent = start; parent < start + cohort_size; parent += stride) {
      acy_multipoly_cohort_and_inner(
        parent,
        cohort_size_base,
        cohort_shape,
        seed,
        &cohort,
        &child
      );
      fprintf(fout, "%lu 2\n", parent);
      fprintf(fout, "%lu 1\n", cohort * cohort_size + child);
    }
  }
  fclose(fout);
  return 0;
}

int acy_test_table_construction() {
  id disttable[] = {
    1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 12, 9, 6, 3, 2, 1
  };
  id table_size = 16;
  id inv_sumtree_size;
  id *sumtable, *inv_sumtree;

  // Turn our distribution table into a sum table and an inverse sum tree:
  acy_create_tables(
    disttable,
    table_size,
    &sumtable,
    &inv_sumtree,
    &inv_sumtree_size
  );

  id sumtable_result[] = {
    0, 1, 3, 6, 12, 21, 33, 41, 47, 52, 56, 59, 61, 63, 64, 65, 66
  };

  id inv_sumtree_result[] = {
    47,
    12,                    61,
    3,          33,        56,            64,
    1,    6,    21,   41,  52,    59,     63,     65,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  };

  for (id i = 0; i < table_size + 1; ++i) {
    if (sumtable[i] != sumtable_result[i]) {
      fprintf(
        stderr,
        "Sum table entry [%lu] is incorrect: %lu != %lu.\n",
        i, sumtable[i], sumtable_result[i]
      );
      fprintf(stderr, "Full table: ");
      for (id j = 0; j < table_size + 1; ++j) {
        fprintf(stderr, "%lu ", sumtable[j]);
      }
      fprintf(stderr, "\n");
      fprintf(stderr, "Correct:    ");
      for (id j = 0; j < table_size + 1; ++j) {
        fprintf(stderr, "%lu ", sumtable_result[j]);
      }
      fprintf(stderr, "\n");
      return i + 1;
    }
  }

  if (inv_sumtree_size != 31) {
    fprintf(
      stderr,
      "Sum tree size is incorrect! %lu != 31\n",
      inv_sumtree_size
    );
    return 50;
  }
  for (id i = 0; i < inv_sumtree_size; ++i) {
    if (inv_sumtree[i] != inv_sumtree_result[i]) {
      fprintf(
        stderr,
        "Inverse sum tree entry [%lu] is incorrect: %lu != %lu.\n",
        i, inv_sumtree[i], inv_sumtree_result[i]
      );
      fprintf(stderr, "Full tree: ");
      for (id j = 0; j < inv_sumtree_size; ++j) {
        fprintf(stderr, "%lu ", inv_sumtree[j]);
      }
      fprintf(stderr, "\n");
      fprintf(stderr, "Correct:   ");
      for (id j = 0; j < inv_sumtree_size; ++j) {
        fprintf(stderr, "%lu ", inv_sumtree_result[j]);
      }
      fprintf(stderr, "\n");
      return i + 100;
    }
  }
  acy_cleanup_tables(sumtable, inv_sumtree);
  return 0;
}

int acy_test_show_default_table() {
  id disttable[] = { // default age-at-birth-of-first-child for sci-fi
     1,  1,  2,  3,  9, // ages 15--19
    17, 23, 25, 27, 29, // ages 20--25
    31, 34, 35, 36, 37, // ages 26--30
    38, 39, 40, 39, 37, // ages 31--35
    35, 32, 30, 27, 24, // ages 36--40
    20, 16, 11, 10,  9, // ages 41--45
     7,  4,  2,  1,  1, // ages 46--50
     1,  1,  1,  1,  1, // ages 51--55
  };
  id table_size = 40;
  id inv_sumtree_size;
  id *sumtable, *inv_sumtree;

  // Turn our distribution table into a sum table and an inverse sum tree:
  acy_create_tables(
    disttable,
    table_size,
    &sumtable,
    &inv_sumtree,
    &inv_sumtree_size
  );

  fprintf(stdout, "\nSumtable:\n");
  fprintf(stdout, "{ ");
  for (id i = 0; i < table_size; ++i) {
    fprintf(stdout, "%lu, ", sumtable[i]);
  }
  fprintf(stdout, "%lu }\n", sumtable[table_size]);

  fprintf(stdout, "\nInverse Sumtree (size %lu):\n", inv_sumtree_size);
  fprintf(stdout, "{ ");
  for (id i = 0; i < inv_sumtree_size - 1; ++i) {
    fprintf(stdout, "%lu, ", inv_sumtree[i]);
  }
  fprintf(stdout, "%lu }\n", inv_sumtree[inv_sumtree_size - 1]);

  acy_cleanup_tables(sumtable, inv_sumtree);
  return 0;
}

int acy_test_table_use() {
  id disttable[] = {
    1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 12, 9, 6, 3, 2, 1
  };
  id table_size = 16;
  id inv_sumtree_size;
  id *sumtable, *inv_sumtree;

  // Turn our distribution table into a sum table and an inverse sum tree:
  acy_create_tables(
    disttable,
    table_size,
    &sumtable,
    &inv_sumtree,
    &inv_sumtree_size
  );

  id sumtable_result[] = {
    0, 1, 3, 6, 12, 21, 33, 41, 47, 52, 56, 59, 61, 63, 64, 65, 66
  };

  id inv_results[] = {
    0,
    1, 1,
    2, 2, 2,
    3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8,
    9, 9, 9, 9,
    10, 10, 10,
    11, 11,
    12, 12,
    13,
    14,
    15,
    15, // extra out-of-band results
    16,
  };

  for (id i = 0; i < table_size + 1; ++i) {
    id sum = acy_tablesum(i, sumtable);
    if (sum != sumtable_result[i]) {
      fprintf(
        stderr,
        "Sum table lookup [%lu] failed: %lu != %lu.\n",
        i, sum, sumtable_result[i]
      );
      return i + 1;
    }
  }

  for (id i = 0; i < sumtable_result[table_size] + 1; ++i) {
    id invsum = acy_inv_tablesum(i, inv_sumtree, inv_sumtree_size);
    if (invsum != inv_results[i]) {
      fprintf(
        stderr,
        "Inverse sum lookup [%lu] failed: %lu != %lu.\n",
        i, invsum, inv_results[i]
      );
      fprintf(stderr, "Full tree: ");
      for (id j = 0; j < inv_sumtree_size; ++j) {
        fprintf(stderr, "%lu ", inv_sumtree[j]);
      }
      return i + 100;
    }
  }

  acy_cleanup_tables(sumtable, inv_sumtree);
  return 0;
}

int acy_test_find_tabulated_cohort_and_inner() {
  id i;
  id my_cohort, inner; 

  id seed = 1728;
  id disttable[] = {
    1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 12, 9, 6, 3, 2, 1
  };
  id table_size = 16;
  id inv_sumtree_size;
  id *sumtable, *inv_sumtree;

  // Turn our distribution table into a sum table and an inverse sum tree:
  acy_create_tables(
    disttable,
    table_size,
    &sumtable,
    &inv_sumtree,
    &inv_sumtree_size
  );

  id cohort_size = acy_tablesum(table_size, sumtable);

  id reversed;
  for (i = 89898128; i < 89898128 + 3921831; i += 12817) {
    acy_tabulated_cohort_and_inner(
      i,
      sumtable,
      table_size,
      inv_sumtree,
      inv_sumtree_size,
      seed,
      &my_cohort,
      &inner
    );
    if (inner >= cohort_size) {
      fprintf(
        stderr,
        "Tabulated cohort index out-of-bounds: %lu → %lu/%lu [%lu]\n",
        i, my_cohort, inner, cohort_size
      );
      return (int) i+1;
    }
    reversed = acy_tabulated_cohort_outer(
      my_cohort,
      inner,
      sumtable,
      table_size,
      inv_sumtree,
      inv_sumtree_size,
      seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Tabulated cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  acy_cleanup_tables(sumtable, inv_sumtree);
  return 0;
}

int acy_test_tabulated_cohort_sections_visual() {
  id i;

  id seed = 1728;
  id disttable[] = {
    6, 16, 3, 1
  };
  id table_size = 4;
  id inv_sumtree_size;
  id *sumtable, *inv_sumtree;

  // Turn our distribution table into a sum table and an inverse sum tree:
  acy_create_tables(
    disttable,
    table_size,
    &sumtable,
    &inv_sumtree,
    &inv_sumtree_size
  );

  fprintf(stdout, "\nSumtable: ");
  for (int i = 0; i < table_size+1; ++i) {
    fprintf(stdout, "%lu, ", sumtable[i]);
  }
  fprintf(stdout, "\n");
  id cohort_size = sumtable[table_size];
  fprintf(stdout, "Cohort size: %lu\n", cohort_size);

  id mxc, mxi;
  size_t lines = table_size * 2;
  char cohorts[lines*cohort_size+1];
  char inners[lines*cohort_size+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < lines*cohort_size; ++i) {
    acy_tabulated_cohort_and_inner(
      i,
      sumtable,
      table_size,
      inv_sumtree,
      inv_sumtree_size,
      seed,
      &mxc,
      &mxi
    );
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    if (cohorts[i] == '1') {
      inners[i] = (char) (0x41 + (mxi % 26));
    } else {
      inners[i] = '-';
    }
  }
  cohorts[lines*cohort_size] = '\0';
  inners[lines*cohort_size] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < cohort_size; ++j) {
      fputc(cohorts[j + cohort_size*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < cohort_size; ++j) {
      fputc(inners[j + cohort_size*i], stdout);
    }
    fputc('\n', stdout);
    if (i % cohort_size == cohort_size - 1) {
      fputc('\n', stdout);
    }
  }
  fputc('\n', stdout);

  acy_cleanup_tables(sumtable, inv_sumtree);
  return 0;
}

/*
int acy_test_count_multipoly_cohorts() {
  id i;
  id cohort_size;
  id cohort_shape;
  id cohort_size_base;

  id seed = 10920192831;

  id target_sizes[]  = { 24, 48, 1025, 9472, 30458 };
  id target_shapes[] = {  2,  5,    3,    8,    32 };

  id target;
  for (target = 0; target < 5; ++target) {
    cohort_size = target_sizes[target];
    cohort_shape = target_shapes[target];

    acy_multipoly_smaller_cohort_size(
      cohort_shape,
      cohort_size,
      &cohort_size,
      &cohort_size_base
    );

    id sample_start = cohort_size * cohort_size_base * 300;

    fprintf(
      stdout,
      "\nMulipoly cohort size/base: %lu/%lu\n",
      cohort_size,
      cohort_size_base
    );

    // count cohorts & indices seen across two super-cohorts
    id mxc, mxi;
    id explore = cohort_size * cohort_size_base * 2;
    id possible_cohorts = cohort_size_base * 3 + 1; // a bit liberal

    id* cohort_counts = (id*) malloc(
      sizeof(id) * possible_cohorts
    );
    id* inner_counts = (id*) malloc(
      sizeof(id) * cohort_size * possible_cohorts
    );

    // zero out stuff:
    for (i = 0; i < possible_cohorts; ++i) {
      cohort_counts[i] = 0;
      for (id j = 0; j < cohort_size; ++j) {
        inner_counts[i*cohort_size + j] = 0;
      }
    }

    // counting occurrences:
    id first_mxc = UNLIKELY;
    for (i = sample_start; i < sample_start + explore; ++i) {
      acy_multipoly_cohort_and_inner(
        i,
        cohort_size_base,
        cohort_shape,
        seed,
        &mxc,
        &mxi
      );
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      mxc -= first_mxc;
      if (mxc >= possible_cohorts) {
        fprintf(
          stderr,
          "\nMulipoly cohort out-of-bounds while counting: %lu/%lu\n",
          mxc,
          possible_cohorts
        );
        return i+1;
      }
      cohort_counts[mxc] += 1;
      if (mxi >= cohort_size) {
        fprintf(
          stderr,
          "\nMulipoly inner out-of-bounds while counting: %lu/%lu\n",
          mxi,
          cohort_size
        );
        continue;
        return i+1;
      }
      inner_counts[mxc * cohort_size + mxi] += 1;
    }
    // print totals for first few targets:
    if (target < 2) {
      fprintf(stdout, "\nMultipolynomial cohort observations:\n");
      for (i = 0; i < possible_cohorts; ++i) {
        fprintf(stdout, " %3lu", i);
      }
      fputc('\n', stdout);
      for (i = 0; i < possible_cohorts; ++i) {
        fprintf(stdout, " %3lu", cohort_counts[i]);
      }
      fputc('\n', stdout);

      fprintf(stdout, "\nMultipolynomial inner observations:\n   ");
      id width = (80/3)-1;
      if (width > cohort_size) {
        width = cohort_size;
      }
      for (i = 0; i < width; ++i) {
        fprintf(stdout, " %2lu", i);
      }
      fputc('\n', stdout);
      for (i = 0; i < possible_cohorts; ++i) {
        fprintf(stdout, "%-2lu", i);
        if (cohort_counts[i] == cohort_size) {
          fputc('~', stdout);
        } else {
          fputc(':', stdout);
        }
        for (id j = 0; j < width; ++j) {
          fprintf(stdout, " %2lu", inner_counts[i*cohort_size+j]);
        }
        fputc('\n', stdout);
      }
    }
    fputc('\n', stdout);
    // limits on totals:
    for (i = 0; i < possible_cohorts; ++i) {
      if (
      i >= cohort_size_base - 1
   && i < 2*cohort_size_base - 1
   && cohort_counts[i] != cohort_size
      ) {
        fprintf(
          stderr, 
          "\nMulipoly cohort counting error: cohort %lu found %lu/%lu times.\n",
          i, cohort_counts[i], cohort_size
        );
        return i+1;
      }
      for (id j = 0; j < cohort_size; ++j) {
        if (inner_counts[i*cohort_size + j] > 1) {
          fprintf(
            stderr, 
            "\nMulipoly inner over-count error: "
              "inner %lu in cohort %lu found %lu/1 times.\n",
            j, i, inner_counts[i*cohort_size + j]
          );
          return i+1;
        }
      }
    }

    free(cohort_counts);
    free(inner_counts);
  }

  return 0;
}

int acy_test_multipoly_cohort_gnuplot() {
  id cohort_size = 200;
  id cohort_shape = 16;

  id cohort_size_base;

  acy_multipoly_nearest_cohort_size(
    cohort_shape,
    cohort_size,
    &cohort_size,
    &cohort_size_base
  );

  id n_batches = 2 * cohort_size_base;

  id n_samples = cohort_size;

  id seed;
  id outer, inner, cohort;

  char* scriptfile = "test/cohort/multipoly-cohort-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multipoly-cohort-data.gpt\n"
    "# gnuplot script for plotting multipoly-cohort-data.dat\n"
    "set term png\n"
    "set output \"multipoly-cohort-data.png\"\n"
    "set title \"Multi-Polynomial Cohorts\"\n"
    "set key off\n"
    "set xlabel \"Relative Outer\"\n"
    "set ylabel \"Relative Inner\"\n"
    "datafile = 'multipoly-cohort-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multipoly-cohort-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples;
  id outers[n_samples*n_batches];
  id inners[n_samples*n_batches];
  id cohorts[n_samples*n_batches];
  id batch = 0;
  id min_cohort = 0 - 1;
  id max_cohort = 0;
  id idx = 0;
  id beginning = 3298019;
  for (
    id start = beginning;
    start < beginning + increment * n_batches;
    start += increment
  ) {
    idx = n_samples*batch;
    seed = acy_prng(start, start + 66489419814);
    for (outer = start; outer < start + n_samples; ++outer) {
      acy_multipoly_cohort_and_inner(
        outer,
        cohort_size_base,
        cohort_shape,
        seed,
        &cohort,
        &inner
      );
      outers[idx] = outer - beginning;
      cohorts[idx] = cohort;
      inners[idx] = inner;
      if (cohort < min_cohort) { min_cohort = cohort; }
      if (cohort > max_cohort) { max_cohort = cohort; }
      idx += 1;
    }
    batch += 1;
  }
  for (id coh = min_cohort; coh < max_cohort+1; ++coh) {
    fprintf(fout, "\n\n\"Inners for cohort %lu:\"\n", coh);
    for (idx = 0; idx < n_samples*n_batches; ++idx) {
      if (cohorts[idx] == coh) {
        fprintf(
          fout,
          "%lu %lu\n",
          outers[idx],
          // coh - min_cohort
          // inners[idx]
          inners[idx] + (coh - min_cohort) * cohort_size
        );
      }
    }
  }
  fclose(fout);
  return 0;
}

int acy_test_multipoly_generations_gnuplot() {
  id n_batches = 4;
  id stride = 10;

  id cohort_size = 1000;
  id cohort_shape = 4;

  id cohort_size_base;

  acy_multipoly_nearest_cohort_size(
    cohort_shape,
    cohort_size,
    &cohort_size,
    &cohort_size_base
  );

  id seed;
  id parent, cohort, child;

  char* scriptfile = "test/cohort/multipoly-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multipoly-data.gpt\n"
    "# gnuplot script for plotting multipoly-data.dat\n"
    "set term png\n"
    "set output \"multipoly-data.png\"\n"
    "set key off\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"ID\"\n"
    "set ylabel \"Generation\"\n"
    "set yrange [0:3]\n"
    "datafile = 'multipoly-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multipoly-data.dat", "w");
  fprintf(fout, "# ID Generation\n");
  id increment = cohort_size * 2;
  for (
    id start = 10000;
    start < 10000 + increment * n_batches;
    start += increment
  ) {
    seed = acy_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, seed);
    for (parent = start; parent < start + cohort_size; parent += stride) {
      acy_multipoly_cohort_and_inner(
        parent,
        cohort_size_base,
        cohort_shape,
        seed,
        &cohort,
        &child
      );
      fprintf(fout, "%lu 2\n", parent);
      fprintf(fout, "%lu 1\n", cohort * cohort_size + child);
    }
  }
  fclose(fout);
  return 0;
}
*/
