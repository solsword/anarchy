// vim: syntax=c
/**
 * @file: cohort_tests.cf
 *
 * @description: Unit tests for cohort.h.
 *
 * @author: Peter Mawhorter (pmawhorter@gmail.com)
 */

#include <stdio.h> // for writing files
#include <sys/stat.h> // for chmod

#include "core/cohort.h"

int myc_test_find_cohort() {
  id i, cohort_size;
  id my_cohort, inner; 
  id reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < 391029831; i += 290320) {
      my_cohort = myc_cohort(i, cohort_size);
      inner = myc_cohort_inner(i, cohort_size);
      reversed = myc_cohort_outer(my_cohort, inner, cohort_size);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort reversibility failed: %lu → %lu/%lu → %lu\n",
          i, my_cohort, inner, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_find_cohort_and_inner() {
  id i, cohort_size;
  id my_cohort, inner; 
  id reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < 391029831; i += 290320) {
      myc_cohort_and_inner(i, cohort_size, &my_cohort, &inner);
      reversed = myc_cohort_outer(my_cohort, inner, cohort_size);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort reversibility failed: %lu → %lu/%lu → %lu\n",
          i, my_cohort, inner, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_interleave() {
  id i, cohort_size;
  id interleaved, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      interleaved = myc_cohort_interleave(i, cohort_size);
      reversed = myc_rev_cohort_interleave(interleaved, cohort_size);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort interleave reversibility failed: %lu → %lu → %lu\n",
          i, interleaved, reversed
        );
        return (int) i+1;
      } else if (interleaved >= cohort_size) {
        fprintf(
          stderr,
          "Cohort interleave bounds check failed: %lu → %lu (>= %lu)\n",
          i, interleaved, cohort_size
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_fold() {
  id i, cohort_size;
  id folded, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      folded = myc_cohort_fold(i, cohort_size, 17+i);
      reversed = myc_rev_cohort_fold(folded, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort fold reversibility failed: %lu → %lu → %lu\n",
          i, folded, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_spin() {
  id i, cohort_size;
  id spun, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      spun = myc_cohort_spin(i, cohort_size, 17+i);
      reversed = myc_rev_cohort_spin(spun, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort spin reversibility failed: %lu → %lu → %lu\n",
          i, spun, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_flop() {
  id i, cohort_size;
  id flopped, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      flopped = myc_cohort_flop(i, cohort_size, 17+i);
      reversed = myc_cohort_flop(flopped, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort flop reversibility failed: %lu → %lu → %lu\n",
          i, flopped, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_mix() {
  id i, cohort_size;
  id mixed, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      mixed = myc_cohort_mix(i, cohort_size, 17+i);
      reversed = myc_rev_cohort_mix(mixed, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort mix reversibility failed [%lu]: %lu → %lu → %lu\n",
          cohort_size, i, mixed, reversed
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_spread() {
  id i, cohort_size;
  id spread, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      spread = myc_cohort_spread(i, cohort_size, 1182453 + cohort_size);
      reversed = myc_rev_cohort_spread(
        spread,
        cohort_size,
        1182453 + cohort_size
      );
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort spread reversibility failed [%lu]: %lu → %lu → %lu\n",
          cohort_size, i, spread, reversed
        );
        return (int) i+1;
      } else if (spread >= cohort_size) {
        fprintf(
          stderr,
          "Cohort spread out-of-bounds [%lu]: %lu → %lu\n",
          cohort_size, i, spread
        );
      }
    }
  }

  return 0;
}

int myc_test_cohort_upend() {
  id i, cohort_size;
  id upended, reversed;
  for (cohort_size = 2; cohort_size < 1000; cohort_size += 1) {
    for (i = 0; i < cohort_size; ++i) {
      upended = myc_cohort_upend(i, cohort_size, 17+i);
      reversed = myc_cohort_upend(upended, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort upend reversibility failed [%lu]: %lu → %lu → %lu\n",
          cohort_size, i, upended, reversed
        );
        return (int) i+1;
      } else if (upended >= cohort_size) {
        fprintf(
          stderr,
          "Cohort upend out-of-bounds [%lu]: %lu → %lu\n",
          cohort_size, i, upended
        );
      }
    }
  }

  return 0;
}

int myc_test_cohort_shuffle() {
  id i, cohort_size;
  id shuffled, reversed;
  for (cohort_size = 2; cohort_size < 1000; ++cohort_size) {
    for (i = 0; i < cohort_size; ++i) {
      shuffled = myc_cohort_shuffle(i, cohort_size, 17+i);
      reversed = myc_rev_cohort_shuffle(shuffled, cohort_size, 17+i);
      if (reversed != i) {
        fprintf(
          stderr,
          "Cohort shuffle reversibility failed: %lu → %lu → %lu (size %lu)\n",
          i, shuffled, reversed, cohort_size
        );
        return (int) i+1;
      }
    }
  }

  return 0;
}

int myc_test_cohort_shuffle_visual() {
  id i;
  id cohort_size = 52;
  id s;
  char results[cohort_size+1];
  char *original = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  for (i = 0; i < cohort_size; ++i) {
    s = myc_cohort_shuffle(i, cohort_size, 17);
    results[i] = original[s];
    if (s >= cohort_size) {
      fprintf(
        stderr,
        "Error: Invalid shuffled value:\nI → S    %zu → %zu\n",
        i, s
      );
      return i+1;
    }
  }
  results[cohort_size] = '\0';
  fprintf(stdout, "\nOriginal:         %s\n", original);
  fprintf(stdout, "Shuffle result:   %s\n\n", results);

  return 0;
}

int myc_test_cohort_shuffle_visual_list() {
  id i;
  id cohort_size = 18201821;
  id sample_size = 12;
  id s;
  fprintf(stdout, "\nShuffle sample (cohort size is %lu):\n", cohort_size);
  for (i = cohort_size/2; i < cohort_size/2 + sample_size; ++i) {
    s = myc_cohort_shuffle(i, cohort_size, 84398384391);
    if (s >= cohort_size) {
      fprintf(
        stderr,
        "Error: Invalid shuffled value:\nI → S    %zu → %zu\n",
        i, s
      );
      return i+1;
    }
    fprintf(stdout, "  %zu → %zu\n", i, s);
  }
  fprintf(stdout, "\n");

  cohort_size = 300000000000;
  fprintf(stdout, "\nShuffle sample (cohort size is %lu):\n", cohort_size);
  for (i = cohort_size/2; i < cohort_size/2 + sample_size; ++i) {
    s = myc_cohort_shuffle(i, cohort_size, 1654686134);
    if (s >= cohort_size) {
      fprintf(
        stderr,
        "Error: Invalid shuffled value:\nI → S    %zu → %zu\n",
        i, s
      );
      return i+1;
    }
    fprintf(stdout, "  %zu → %zu\n", i, s);
  }
  fprintf(stdout, "\n");

  return 0;
}

int myc_test_find_mixed_cohort() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    my_cohort = myc_mixed_cohort(i, cohort_size, cohort_seed);
    inner = myc_mixed_cohort_inner(i, cohort_size, cohort_seed);
    reversed = myc_mixed_cohort_outer(
      my_cohort,
      inner,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Mixed cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int myc_test_find_mixed_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    myc_mixed_cohort_and_inner(i, cohort_size, cohort_seed, &my_cohort, &inner);
    reversed = myc_mixed_cohort_outer(
      my_cohort,
      inner,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Mixed cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

#define UNLIKELY 102901211
int myc_test_mixed_cohort_visual() {
  id i;
  id cohort_size = 10;
  id cohort_seed = 1;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    for (i = 0; i < length; ++i) {
      myc_mixed_cohort_and_inner(i, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x30 + mxi);
    }
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int myc_test_find_biased_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id bias = myc_nearest_bias(0.8);
  id reversed;
  for (i = 0; i < 391029831; i += 290320) {
    myc_biased_cohort_and_inner(
      i,
      bias,
      cohort_size,
      cohort_seed,
      &my_cohort,
      &inner
    );
    reversed = myc_biased_cohort_outer(
      my_cohort,
      inner,
      bias,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Biased cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int myc_test_biased_cohort_visual() {
  id i;
  id cohort_size = 30;
  id cohort_seed = 1;
  id bias;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    bias = myc_nearest_bias(0.25 * cohort_seed);
    for (i = 0; i < length; ++i) {
      myc_biased_cohort_and_inner(
        i,
        bias,
        cohort_size,
        cohort_seed,
        &mxc,
        &mxi
      );
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x41 + mxi);
    }
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int myc_test_exp_split_visual() {
  fputc('\n', stdout);
  id sections = 20;
  id section_width = 32;
  for (id i = 0; i < sections; ++i) {
    id result = myc_exp_split(0.05, sections, section_width, i);
    for (id j = 0; j < section_width; ++j) {
      if (j < result) {
        fputc('#', stdout);
      } else {
        fputc('-', stdout);
      }
    }
    fprintf(stdout, " :%02lu", result);
    fputs("    ", stdout);
    result = myc_exp_split(-0.05, sections, section_width, i);
    for (id j = 0; j < section_width; ++j) {
      if (j < result) {
        fputc('#', stdout);
      } else {
        fputc('-', stdout);
      }
    }
    fprintf(stdout, " :%02lu", result);
    fputc('\n', stdout);
  }
  fputc('\n', stdout);
  return 0;
}

int myc_test_multiexp_split_visual() {
  fputc('\n', stdout);
  id sections = 20;
  id section_width = 32;
  id n_layers = 4;
  for (id i = 0; i < sections; ++i) {
    for (id j = 0; j < section_width; ++j) {
      id layer = myc_multi_exp_get_layer(
        j,
        0.05,
        sections,
        section_width,
        i,
        n_layers
      );
      fputc(0x30 + layer, stdout);
    }
    fputs("    ", stdout);
    for (id j = 0; j < section_width; ++j) {
      id layer = myc_multi_exp_get_layer(
        j,
        -0.05,
        sections,
        section_width,
        i,
        n_layers
      );
      fputc(0x30 + layer, stdout);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);
  return 0;
}

int myc_test_exp_cohort_sections_visual() {
  id i;
  id sections = 20;
  id section_width = EXP_SECTION_RESOLUTION;
  id cohort_size = sections * section_width;
  id cohort_seed = 1;
  float shape = -0.05;
  id mxc, mxi;
  size_t lines = cohort_size*2 / section_width;
  char cohorts[lines*section_width+1];
  char inners[lines*section_width+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < cohort_size*2; ++i) {
    myc_exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    inners[i] = (char) (0x41 + (mxi % 26) + ((mxc - first_mxc)%2)*0x20);
  }
  cohorts[lines*section_width] = '\0';
  inners[lines*section_width] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(cohorts[j + section_width*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(inners[j + section_width*i], stdout);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);

  return 0;
}

int myc_test_exp_cohort_visual() {
  id i;
  id cohort_size = 30;
  id cohort_seed = 1;
  float shape;
  id mxc, mxi;
  size_t length = 60;
  char cohorts[3*length];
  char inners[3*length];
  id first_mxc = UNLIKELY;
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    if (cohort_seed == 0) {
      shape = 0.05;
    } else if (cohort_seed == 1) {
      shape = -0.05;
    } else {
      shape = 0.5;
    }
    for (i = 0; i < length; ++i) {
      myc_exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
      if (first_mxc == UNLIKELY) { first_mxc = mxc; }
      cohorts[length*cohort_seed + i] = (char) (0x30 + mxc - first_mxc);
      inners[length*cohort_seed + i] = (char) (0x41 + mxi);
    }
  }
  fputc('\n', stdout);
  for (cohort_seed = 0; cohort_seed < 3; ++cohort_seed) {
    fprintf(stdout, "Cohorts:   ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(cohorts[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fprintf(stdout, "Inners:    ");
    for (i = 0; i < 6; ++i) {
      for (int j = 0; j < 10; ++j) {
        fputc(inners[length*cohort_seed + i*10 + j], stdout);
      }
      fputc(' ', stdout);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int myc_test_exp_cohort_inners() {
  id i;
  id sections = 10;
  id section_width = EXP_SECTION_RESOLUTION;
  id cohort_size = sections * section_width;
  id cohort_seed = 752812;
  float shape = 0.05;
  id mxc, mxi;
  id cohorts[cohort_size*3];
  id inners[cohort_size*3];
  id min_mxc = (id) -1;

  // Now fill in the cohorts/inners arrays:
  for (i = 0; i < cohort_size*3; ++i) {
    myc_exp_cohort_and_inner(i, shape, cohort_size, cohort_seed, &mxc, &mxi);
    if (mxi >= cohort_size) {
      fprintf(stderr, "Error: out-of-range cohort inner %zu!\n", mxi);
    } else {
      cohorts[i] = mxc;
      inners[i] = mxi;
    }
    if (mxc < min_mxc) {
      min_mxc = mxc;
    }
  }

  char observed[cohort_size*4];
  // Zero-out the observed array:
  for (i = 0; i < cohort_size*4; ++i) {
    observed[i] = 0;
  }
  for (i = 0; i < cohort_size*3; ++i) {
    mxc = cohorts[i];
    mxi = inners[i];
    observed[mxi + (cohort_size * (mxc - min_mxc))] += 1;
  }
  fputc('\n', stdout);
  fprintf(stdout, "Cohort size: %zu\n", cohort_size);
  fputc('\n', stdout);
  // Observed counts for min cohort:
  for (mxc = min_mxc; mxc < min_mxc + 4; ++mxc) {
    fprintf(stdout, "Observations of inner indices for cohort %zu:\n\n", mxc);
    for (i = 0; i < cohort_size; ++i) {
      fprintf(stdout, "%d ", observed[i + (mxc - min_mxc)*cohort_size]);
    }
    fputc('\n', stdout);
    fputc('\n', stdout);
  }

  return 0;
}

int myc_test_find_exp_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  float shape = 0.25;
  id reversed;
  for (i = 0; i < 391831; i += 12817) {
    myc_exp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_seed,
      &my_cohort,
      &inner
    );
    reversed = myc_exp_cohort_outer(
      my_cohort,
      inner,
      shape,
      cohort_size,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Exponential cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int myc_test_find_multiexp_cohort_and_inner() {
  id i;
  id my_cohort, inner; 
  id cohort_size = 10000;
  id cohort_seed = 1728;
  id cohort_layers = 8;
  float shape = 0.25;
  id reversed;
  for (i = 89898128; i < 89898128 + 3921831; i += 12817) {
    myc_multiexp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed,
      &my_cohort,
      &inner
    );
    if (inner >= cohort_size) {
      fprintf(
        stderr,
        "Multi-exponential cohort index out-of-bounds: %lu → %lu/%lu [%lu]\n",
        i, my_cohort, inner, cohort_size
      );
      return (int) i+1;
    }
    reversed = myc_multiexp_cohort_outer(
      my_cohort,
      inner,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed
    );
    if (reversed != i) {
      fprintf(
        stderr,
        "Multi-exponential cohort reversibility failed: %lu → %lu/%lu → %lu\n",
        i, my_cohort, inner, reversed
      );
      return (int) i+1;
    }
  }

  return 0;
}

int myc_test_multiexp_cohort_sections_visual() {
  id i;
  id sections = 20;
  id section_width = EXP_SECTION_RESOLUTION;
  id cohort_size = sections * section_width;
  id cohort_layers = 4;
  id cohort_seed = 1;
  // TODO: Get this test working with a negative shape!
  float shape = 0.05;
  id mxc, mxi;
  size_t lines = cohort_size*2 / section_width;
  char cohorts[lines*section_width+1];
  char inners[lines*section_width+1];
  id first_mxc = UNLIKELY;
  for (i = 0; i < cohort_size*2; ++i) {
    myc_multiexp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed,
      &mxc,
      &mxi
    );
    if (first_mxc == UNLIKELY) { first_mxc = mxc; }
    cohorts[i] = (char) (0x30 + mxc - first_mxc);
    inners[i] = (char) (0x41 + (mxi % 26) + ((mxc - first_mxc)%2)*0x20);
  }
  cohorts[lines*section_width] = '\0';
  inners[lines*section_width] = '\0';
  fputc('\n', stdout);
  for (i = 0; i < lines; ++i) {
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(cohorts[j + section_width*i], stdout);
    }
    fputs("    ", stdout);
    for (int j = 0; j < section_width; ++j) {
      fputc(inners[j + section_width*i], stdout);
    }
    fputc('\n', stdout);
  }
  fputc('\n', stdout);

  return 0;
}

int myc_test_cohort_shuffle_gnuplot() {
  id n_samples = 1000;
  id n_batches = 3;
  id cohort_size = 1000;
  id seed;
  id index, shuffled;

  char* scriptfile = "test/cohort/shuffle-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# shuffle-data.gpt\n"
    "# gnuplot script for plotting shuffle-data.dat\n"
    "set term png\n"
    "set output \"shuffle-data.png\"\n"
    "set title \"Parent/Child IDs\"\n"
    "set xlabel \"Parent\"\n"
    "set ylabel \"Child\"\n"
    "datafile = 'shuffle-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/shuffle-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples + n_samples/5;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    seed = myc_prng(start, start + 4654681615348494);
    fprintf(fout, "\n\n\"Batch at %lu (seed %lu)\"\n", start, seed);
    for (index = start; index < start + n_samples; ++index) {
      shuffled = myc_cohort_shuffle(index, cohort_size, seed);
      fprintf(fout, "%lu %lu\n", index, shuffled);
    }
  }
  fclose(fout);
  return 0;
}

int myc_test_exp_cohort_gnuplot() {
  id n_batches = 3;
  //id cohort_size = 100;
  id cohort_size = 37*105;
  id n_samples = cohort_size;
  float cohort_shape = 0.02;
  id seed;
  id outer, inner, cohort;

  char* scriptfile = "test/cohort/exp-cohort-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# exp-cohort-data.gpt\n"
    "# gnuplot script for plotting exp-cohort-data.dat\n"
    "set term png\n"
    "set output \"exp-cohort-data.png\"\n"
    "set title \"Exponential Cohorts\"\n"
    "set key off\n"
    "set xlabel \"Outer\"\n"
    "set ylabel \"Relative Inner\"\n"
    "datafile = 'exp-cohort-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/exp-cohort-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples;
  id outers[n_samples*n_batches];
  id inners[n_samples*n_batches];
  id cohorts[n_samples*n_batches];
  id batch = 0;
  id min_cohort = 0 - 1;
  id max_cohort = 0;
  id idx = 0;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    idx = n_samples*batch;
    seed = myc_prng(start, start + 66489419814);
    for (outer = start; outer < start + n_samples; ++outer) {
      myc_exp_cohort_and_inner(
        outer - (cohort_size*2),
        cohort_shape,
        cohort_size,
        seed,
        &cohort,
        &inner
      );
      outers[idx] = outer;
      cohorts[idx] = cohort;
      inners[idx] = inner;
      if (cohort < min_cohort) { min_cohort = cohort; }
      if (cohort > max_cohort) { max_cohort = cohort; }
      idx += 1;
    }
    batch += 1;
  }
  for (id coh = min_cohort; coh < max_cohort+1; ++coh) {
    fprintf(fout, "\n\n\"Inners for cohort %lu (batch %lu):\"\n", coh, batch);
    for (idx = 0; idx < n_samples*n_batches; ++idx) {
      if (cohorts[idx] == coh) {
        fprintf(
          fout,
          "%lu %lu\n",
          outers[idx],
          inners[idx] + (coh - min_cohort) * cohort_size
        );
      }
    }
  }
  fclose(fout);
  return 0;
}

int myc_test_multiexp_cohort_gnuplot() {
  id n_batches = 3;
  id cohort_layers = 4;
  id cohort_size = 107 * cohort_layers;
  id n_samples = cohort_size;
  float cohort_shape = 0.02;
  id seed;
  id outer, inner, cohort;

  char* scriptfile = "test/cohort/multi-exp-cohort-data.gpt";
  FILE *fout = fopen(scriptfile, "w");
  fprintf(
    fout,
    "#!/usr/bin/env gnuplot\n"
    "# multi-exp-cohort-data.gpt\n"
    "# gnuplot script for plotting multi-exp-cohort-data.dat\n"
    "set term png\n"
    "set output \"multi-exp-cohort-data.png\"\n"
    "set title \"Multi-Exponential Cohorts\"\n"
    "set key off\n"
    "set xlabel \"Outer\"\n"
    "set ylabel \"Relative Inner\"\n"
    "datafile = 'multi-exp-cohort-data.dat'\n"
    "stats datafile\n"
    "plot for [IDX=1:STATS_blocks] datafile index (IDX-1) "
      "with points title columnheader(1)\n"
    "quit\n"
  );
  fclose(fout);
  chmod(scriptfile, S_IRUSR | S_IWUSR | S_IXUSR);
  fout = fopen("test/cohort/multi-exp-cohort-data.dat", "w");
  fprintf(fout, "# Original Shuffled\n");
  id increment = n_samples;
  id outers[n_samples*n_batches];
  id inners[n_samples*n_batches];
  id cohorts[n_samples*n_batches];
  id batch = 0;
  id min_cohort = 0 - 1;
  id max_cohort = 0;
  id idx = 0;
  for (
    id start = 3298019;
    start < 3298019 + increment * n_batches;
    start += increment
  ) {
    idx = n_samples*batch;
    seed = myc_prng(start, start + 66489419814);
    for (outer = start; outer < start + n_samples; ++outer) {
      myc_multiexp_cohort_and_inner(
        outer,
        cohort_shape,
        cohort_size,
        cohort_layers,
        seed,
        &cohort,
        &inner
      );
      outers[idx] = outer;
      cohorts[idx] = cohort;
      inners[idx] = inner;
      if (cohort < min_cohort) { min_cohort = cohort; }
      if (cohort > max_cohort) { max_cohort = cohort; }
      idx += 1;
    }
    batch += 1;
  }
  for (id coh = min_cohort; coh < max_cohort+1; ++coh) {
    fprintf(fout, "\n\n\"Inners for cohort %lu (batch %lu):\"\n", coh, batch);
    for (idx = 0; idx < n_samples*n_batches; ++idx) {
      if (cohorts[idx] == coh) {
        fprintf(
          fout,
          "%lu %lu\n",
          outers[idx],
          inners[idx] + (coh - min_cohort) * cohort_size
        );
      }
    }
  }
  fclose(fout);
  return 0;
}

int myc_test_count_multiexp_cohorts() {
  id i;
  id cohort_size = 1037;
  id cohort_layers = 4;
  id cohort_seed = 10920192831;
  float shape = 0.05;
  id mxc, mxi;
  id possible_layers = cohort_layers * 2 + 1;
  id cohort_counts[possible_layers];
  id inner_counts[cohort_size * possible_layers];
  // zero out stuff:
  for (i = 0; i < possible_layers; ++i) {
    cohort_counts[i] = 0;
    for (id j = 0; j < cohort_size; ++j) {
      inner_counts[i*cohort_size + j] = 0;
    }
  }
  // count cohorts & indices seen:
  for (i = 0; i < cohort_size * possible_layers; ++i) {
    myc_multiexp_cohort_and_inner(
      i,
      shape,
      cohort_size,
      cohort_layers,
      cohort_seed,
      &mxc,
      &mxi
    );
    if (mxc >= possible_layers) {
      fprintf(
        stderr,
        "\nMultiexp cohort out-of-bounds: %lu/%lu\n",
        mxc,
        possible_layers
      );
      return i+1;
    }
    cohort_counts[mxc] += 1;
    if (mxi >= cohort_size) {
      fprintf(
        stderr,
        "\nMultiexp inner out-of-bounds: %lu/%lu\n",
        mxi,
        cohort_size
      );
      continue;
      //return i+1;
    }
    inner_counts[mxc * cohort_size + mxi] += 1;
  }
  // expected totals:
  for (i = 0; i < possible_layers; ++i) {
    if (cohort_counts[i] != cohort_size) {
      fprintf(
        stderr, 
        "\nMultiexp cohort counting error: cohort %lu found %lu/%lu times.\n",
        i, cohort_counts[i], cohort_size
      );
      return i+1;
    }
    for (id j = 0; j < cohort_size; ++j) {
      if (inner_counts[i*cohort_size + j] != 1) {
        fprintf(
          stderr, 
          "\nMultiexp inner counting error: "
            "inner %lu in cohort %lu found %lu/1 times.\n",
          j, i, inner_counts[i*cohort_size + j]
        );
        return i+1;
      }
    }
  }

  return 0;
}
