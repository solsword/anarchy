// vim: syntax=c
/**
 * @file: family_tests.cf
 *
 * @description: Unit tests for family/family.h/c.
 *
 * @author: Peter Mawhorter (pmawhorter@gmail.com)
 */

#include <stdio.h>

#include "family/family.h"

int myc_test_mothers() {
  id test_generations = 7;
  id valid_generations = 0;
  id parents[test_generations]; 
  id indices[test_generations];
  for (id child = 781312757; child < 1288912891; child += 19842411) {
    valid_generations = 0;
    parents[0] = child;
    // find the parent:
    for (
      valid_generations = 1;
      valid_generations < test_generations;
      ++valid_generations
    ) {
      myc_mother_and_index(
        parents[valid_generations-1],
        &DEFAULT_FAMILY_INFO,
        &parents[valid_generations],
        &indices[valid_generations-1]
      );
      if (parents[valid_generations] == NONE) {
        break;
      }
    }
    for (id i = 0; i < valid_generations - 1; ++i) {
      if (myc_child(
           parents[i+1],
           indices[i],
           &DEFAULT_FAMILY_INFO
         ) != parents[i]
      ) {
        fprintf(
          stderr,
          "Family parent/child broken [%lu] %lu → %lu/%lu | %lu/%lu → %lu\n",
          i,
          parents[i],
          parents[i+1], indices[i],
          parents[i+1], indices[i],
          myc_child(
            parents[i+1],
            indices[i],
            &DEFAULT_FAMILY_INFO
          )
        );
        return child + i+1;
      }
    }
  }
  return 0;
}

int myc_test_mothers_age_stream() {
  id n_patches = 3;
  id n_samples = 60;
  for (
    id start = 372221831718;
    start < 372221831718 + 418831*n_patches;
    start += 418831
  ) {
    fprintf(stdout, "\nMother/child age gaps [%lu]:\n", start);
    for (id child = start; child < start + n_samples; ++child) {
      id mother = myc_mother(child, &DEFAULT_FAMILY_INFO);
      id age_diff = (
        myc_birthdate(child, &DEFAULT_FAMILY_INFO)
      - myc_birthdate(mother, &DEFAULT_FAMILY_INFO)
      ) / ONE_EARTH_YEAR;
      fprintf(stdout, "  %lu → %lu [%lu years]\n", mother, child, age_diff);
    }
  }
  return 0;
}

int myc_test_mothers_age_histogram() {
  id n_samples = 10000;
  id max_age_diff = 50;
  id max_bucket_length = 60;
  id largest_bucket = 0;
  id buckets[max_age_diff];
  id n_patches = 3;
  // 60 equals signs:
  char *bar = "============================================================";
  for (
    id start = 810221831718;
    start < 810221831718 + 219831*n_patches;
    start += 219831
  ) {
    largest_bucket = 0;
    for (id i = 0; i < max_age_diff; ++i) {
      buckets[i] = 0;
    }
    for (id child = start; child < start + n_samples; ++child) {
      id mother = myc_mother(child, &DEFAULT_FAMILY_INFO);
      id age_diff = (
        myc_birthdate(child, &DEFAULT_FAMILY_INFO)
      - myc_birthdate(mother, &DEFAULT_FAMILY_INFO)
      ) / ONE_EARTH_YEAR;
      if (age_diff < max_age_diff) {
        buckets[age_diff] += 1;
        if (buckets[age_diff] > largest_bucket) {
          largest_bucket = buckets[age_diff];
        }
      } else {
        fprintf(
          stderr,
          "\nParent/child with large age gap: %lu → %lu (%lu years)\n",
          mother, child, age_diff
        );
        return child;
      }
    }
    fprintf(stdout, "\nAge difference histogram [%lu]:\n\n", start);
    for (id i = 0; i < max_age_diff; ++i) {
      float normalized = (
        buckets[i]
      * max_bucket_length
      ) / (float) largest_bucket;
      int normint = (int) normalized;
      fprintf(stdout, "  [%03lu] %.*s(%lu)\n", i, normint, bar, buckets[i]);
    }
    fprintf(stdout, "\n");
  }
  return 0;
}

void myc_print_mothers_recursively(
  FILE* stream,
  id parent,
  myc_family_info const * const info,
  id depth_limit
) {
  id nth = 0;
  id child;
  id mbd, cbd;
  while(1) {
    child = myc_child(parent, nth, info);
    if (child == NONE) {
      break;
    }
    mbd = myc_birthdate(parent, info);
    cbd = myc_birthdate(child, info);
    fprintf(
      stream,
      "  %lu -> %lu [ label=\"%d\" ];\n",
      parent,
      child,
      ((int) cbd - (int) mbd) / (int) ONE_EARTH_YEAR
    );
    nth += 1;
    if (depth_limit > 0) {
      myc_print_mothers_recursively(
        stream,
        child,
        info,
        depth_limit - 1
      );
    }
  }
}

int myc_test_mothers_tree_graphviz() {
  id parent;
  char filename[1024];
  myc_family_info *tinfo = myc_create_family_info();
  myc_copy_family_info(&DEFAULT_FAMILY_INFO, tinfo);
  for (id seed = 78138917; seed < 78138917 + 3; ++seed) {
    myc_set_info_seed(tinfo, seed);
    parent = 1000000000;
    // find the great-grandmother:
    for (id i = 0; i < 3; ++i) {
      parent = myc_mother(parent, tinfo);
    }

    // Print the graph:
    snprintf(filename, 1024, "test/family/mothers-graph-%lu.gv", seed);
    FILE *fout = fopen(filename, "w");
    // print edges
    fprintf(fout, "digraph G {\n");
    myc_print_mothers_recursively(
      fout,
      parent,
      tinfo,
      4 // stop at grandchildren of initial person
    );
    fprintf(fout, "}\n");
  }

  myc_destroy_family_info(tinfo);

  return 0;
}
