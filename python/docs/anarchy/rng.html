<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>anarchy.rng API documentation</title>
<meta name="description" content="Core pseud-random number operations which provide reversibility …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>anarchy.rng</code></h1>
</header>
<section id="section-intro">
<p>Core pseud-random number operations which provide reversibility.</p>
<p>rng.py</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Core pseud-random number operations which provide reversibility.

rng.py
&#34;&#34;&#34;

import math


ID_BITS = 64
&#34;&#34;&#34;
The number of bits in an &#34;ID&#34; which is what most functions require as
seeds and/or return. We usually treat these as unsigned integers.
&#34;&#34;&#34;

ID_BYTES = ID_BITS &gt;&gt; 3
&#34;&#34;&#34;
The number of bytes in an &#34;ID&#34; value.
&#34;&#34;&#34;

ID_MASK = (1 &lt;&lt; ID_BITS) - 1
&#34;&#34;&#34;
An &#34;ID&#34; value which is all-ones, to serve as a mask for preventing
overflow.
&#34;&#34;&#34;


def posmod(x, y):
    &#34;&#34;&#34;
    Modulus that&#39;s always positive (x % y) as long as y is positive.

    Note: In python, the built-in % operator works this way, which is
    what this function uses. It is retained for cross-language
    compatibility, but in general the native operator should be preferred
    as it&#39;s faster.
    &#34;&#34;&#34;
    return x % y


def hash_string(s):
    &#34;&#34;&#34;
    A string hashing function.

    See: [StackOverflow answer on hashing strings](https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery).
    &#34;&#34;&#34; # noqa E501
    hash = 0
    if len(s) == 0:
        return hash

    for i, ch in enumerate(s):
        o = ord(ch)
        hash = ((hash &lt;&lt; 5) - hash) + o
        hash &amp;= ID_MASK

    return hash


def mask(bits):
    &#34;&#34;&#34;
    Creates a mask with the given number of 1 bits.
    &#34;&#34;&#34;
    return (1 &lt;&lt; bits) - 1


def byte_mask(n):
    &#34;&#34;&#34;
    Returns a mask that covers just the nth byte (zero-indexed), starting
    from the least-significant digits.
    &#34;&#34;&#34;
    return (1 &lt;&lt; (8 * n)) * 0xff


# Unit PRNG operations
#---------------------

def swirl(x, distance):
    &#34;&#34;&#34;
    Circular bit shift. Distance is capped at 3/4 of ID_BITS.

    Inverse is `rev_swirl`.
    &#34;&#34;&#34;
    distance %= (3 * ID_BITS) // 4
    m = mask(distance)
    fall_off = x &amp; m
    shift_by = (ID_BITS - distance)
    return (
        (x &gt;&gt; distance)
      | (fall_off &lt;&lt; shift_by)
    ) &amp; ID_MASK


def rev_swirl(x, distance):
    &#34;&#34;&#34;
    Inverse of `swirl`.
    &#34;&#34;&#34;
    distance %= (3 * ID_BITS) // 4
    m = mask(distance)
    m = mask(distance)
    fall_off = x &amp; (m &lt;&lt; (ID_BITS - distance))
    shift_by = (ID_BITS - distance)
    return (
        (x &lt;&lt; distance)
      | (fall_off &gt;&gt; shift_by)
    ) &amp; ID_MASK


def fold(x, where):
    &#34;&#34;&#34;
    Folds lower bits into upper bits using xor. &#39;where&#39; is restricted to
    fall between 1/4 and 1/2 of ID_BITS.

    Fold is its own inverse.
    &#34;&#34;&#34;
    quarter = ID_BITS // 4
    where = (where % quarter) + quarter
    m = mask(where)
    lower = x &amp; m
    shift_by = ID_BITS - where
    return (x ^ (lower &lt;&lt; shift_by)) &amp; ID_MASK


FLOP_MASK = 0xf0f0f0f0f0f0f0f0
&#34;&#34;&#34;
A bit-mask used for the `flop` operation.
&#34;&#34;&#34;


def flop(x):
    &#34;&#34;&#34;
    Flops each 1/2 byte with the adjacent 1/2 byte.

    Flop is its own inverse.
    &#34;&#34;&#34;
    left = x &amp; FLOP_MASK
    right = x &amp; ~FLOP_MASK
    return ((right &lt;&lt; 4) | (left &gt;&gt; 4)) &amp; ID_MASK


def scramble(x):
    &#34;&#34;&#34;
    Implements a reversible linear-feedback-shift-register-like operation.

    Inverse is `rev_scramble`.
    &#34;&#34;&#34;
    trigger = x &amp; 0x80200003
    r = swirl(x, 1)
    r ^= 0x03040610 * (not not trigger) # pseudo-if

    return r &amp; ID_MASK


def rev_scramble(x):
    &#34;&#34;&#34;
    Inverse of `scramble`.
    &#34;&#34;&#34;
    pr = rev_swirl(x, 1)
    trigger = pr &amp; 0x80200003
    if trigger:
        # pr ^= rev_swirl(0x03040610, 1)
        pr ^= 0x06080c20

    return pr &amp; ID_MASK


# PRNG functions
#---------------

def scramble_seed(s):
    &#34;&#34;&#34;
    Scrambles a seed value to help separate RNG sequences generated from
    sequential seeds.
    &#34;&#34;&#34;

    s = s &amp; ID_MASK
    s = ((s + 1) * (3 + (s % 23))) &amp; ID_MASK
    s = fold(s, 11) &amp; ID_MASK # prime
    s = scramble(s) &amp; ID_MASK
    s = swirl(s, s + 23) &amp; ID_MASK # prime
    s = scramble(s) &amp; ID_MASK
    s ^= (s % 153) * scramble(s)
    s = s &amp; ID_MASK

    return s


def prng(x, seed):
    &#34;&#34;&#34;
    Parameters:

    - `x` (int): The current random number (next one is returned).
    - `seed` (int): The seed; each seed will produce a distinct sequence
      of numbers.

    Returns (int): The next random number in the sequence for the given
    seed.

    A reversible pseudo-random number generator. Uses low-level
    reversible functions to scramble a number and produce an
    hard-to-predict result. The `rev_prng` function is the inverse of
    this function.
    &#34;&#34;&#34;

    # seed scrambling:
    seed = scramble_seed(seed)

    # value scrambling:
    x ^= seed
    x = fold(x, seed + 17) # prime
    x = flop(x)
    x = swirl(x, seed + 37) # prime
    x = fold(x, seed + 89) # prime
    x = swirl(x, seed + 107) # prime
    x = scramble(x)
    return x &amp; ID_MASK


def rev_prng(x, seed):
    &#34;&#34;&#34;
    Parameters:

    - `x` (int): the current random number (previous one is returned).
    - `seed` (int): The seed; each seed will produce a distinct
    sequence of numbers.

    Returns (int): The previous random number in the sequence for the
    given seed.

    The inverse of `prng` (see above). Returns the previous number in a
    pseudo-random sequence, so that:

    ```py
    prng(rev_prng(n, seed), seed) == n
    rev_prng(prng(n, seed), seed) == n
    ```
    &#34;&#34;&#34;

    # seed scrambling:
    seed = scramble_seed(seed)

    # value unscrambling:
    x = rev_scramble(x)
    x = rev_swirl(x, seed + 107) # prime
    x = fold(x, seed + 89) # prime
    x = rev_swirl(x, seed + 37) # prime
    x = flop(x)
    x = fold(x, seed + 17) # prime
    x ^= seed
    return x &amp; ID_MASK


def lfsr(x):
    &#34;&#34;&#34;
    Parameters:

    - `x` (int): The current random number.

    Returns (int): The next random number in a pseudo-random sequence.

    Implements a max-cycle-length 64-bit linear-feedback-shift-register.
    See: [the Wikipedia article on Linear Feedback Shift
    Registers](https://en.wikipedia.org/wiki/Linear-feedback_shift_register).
    Note that this is NOT reversible!

    See also: [a PDF table of max-length LFSR
    parameters](http://courses.cse.tamu.edu/walker/csce680/lfsr_table.pdf).
    &#34;&#34;&#34;
    lsb = x &amp; 1
    r = x &gt;&gt; 1
    # pseudo-if
    r ^= lsb * 0xe800000000000000 # 64, 63, 61, 60

    return r &amp; ID_MASK


# Sampling functions
#-------------------

def uniform(seed):
    &#34;&#34;&#34;
    Parameter (int): `seed`--The seed that determines the result (could
      be a result from `prng` or `lfsr`)

    Returns (float): A pseudo-random number between 0 (inclusive) and 1
      (exclusive).
    &#34;&#34;&#34;
    # Note: without this extra scrambling, udist on sequential seeds is
    # *terrible* for seeds below ~1000000.
    sc = scramble_seed(seed)
    sc = prng(prng(sc, sc), seed)
    return (sc % 9223372036854775783) / 9223372036854775783 # prime near 2^63


def normalish(seed):
    &#34;&#34;&#34;
    Parameter (int): `seed`--The seed that determines the result.

    Returns (float): A pseudo-random number between 0 (inclusive) and 1
      (exclusive).

    The result is created by averaging three results from `uniform`, and
    its distribution has a normal-like shape centered at 0.5.
    &#34;&#34;&#34;
    t = 0
    for i in range(3):
        t += uniform(seed + 9182793183 * i)
    return t / 3


def flip(p, seed):
    &#34;&#34;&#34;
    Parameters:

    - `p` (float): The probability of returning True.
    - `seed` (int): The seed value that determines the result.

    Returns (True or False): a decision value.

    Flips a biased coin with probability `p` of being true. Using the
    same seed always gives the same result, but over many seeds the given
    probability is adhered to.
    &#34;&#34;&#34;
    return uniform(prng(seed, seed)) &lt; p


def integer(seed, start, end):
    &#34;&#34;&#34;
    Parameters:

      - `seed` (int): The seed value that determines the result.
      - `start` (int): The minimum possible output value.
      - `end` (int): One more than the maximum possible output value.

    Returns (int): a pseudo-random integer between the start (inclusive)
    and the end (exclusive).

    Returns a number drawn evenly from the given integer range, including
    the lower end but excluding the higher end (even if the lower end is
    given second).

    Distribution bias is about one part in (range/2^63).
    &#34;&#34;&#34;
    return math.floor(uniform(seed) * (end - start)) + start


def exponential(seed, shape):
    &#34;&#34;&#34;
    Parameters:

    - `seed` (int)--The seed that determines the result.
    - `shape` (float):--The lambda shape parameter for the exponential
      distribution. Values between 0.5 and 1.5 are typical, with higher
      values biasing the distribution more towards smaller results.

    Returns (float): A number with an exponential distribution on [0,∞).

    Generates a number from an exponential distribution with the given
    lambda shape parameter.

    See: [this StackExchange answer on exponential
    distribution](https://math.stackexchange.com/questions/28004/random-exponential-like-distribution)
    and [the Wikipedia page for the exponential
    distribution](https://en.wikipedia.org/wiki/Exponential_distribution)
    &#34;&#34;&#34; # noqa E501
    # Note: mathematically since u is on [0, 1) and not (0, 1], we can&#39;t
    # skip the 1- step, since when u = 0, that would be asking for the
    # log of 0. With 1-, the log of 0 would happen when u=1, but our
    # domain is [0, 1) which excludes 1.
    return -math.log(1 - uniform(seed)) / shape


def truncated_exponential(seed, shape):
    &#34;&#34;&#34;
    Parameters:

    - `seed` (int)--The seed that determines the result.
    - `shape` (float)--The lambda shape parameter for the exponential
      distribution. Values between 0.5 and 1.5 are typical, with higher
      values biasing the distribution more towards smaller results.

    Returns (float) A number with a truncated exponential distribution
    on [0, 1].

    Generates a number from a truncated exponential distribution on [0,
    1] with the given lambda shape parameter. See reference material for
    `exponential`.
    &#34;&#34;&#34;
    e = exponential(seed, shape)
    return e - math.floor(e)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="anarchy.rng.FLOP_MASK"><code class="name">var <span class="ident">FLOP_MASK</span></code></dt>
<dd>
<div class="desc"><p>A bit-mask used for the <code><a title="anarchy.rng.flop" href="#anarchy.rng.flop">flop()</a></code> operation.</p></div>
</dd>
<dt id="anarchy.rng.ID_BITS"><code class="name">var <span class="ident">ID_BITS</span></code></dt>
<dd>
<div class="desc"><p>The number of bits in an "ID" which is what most functions require as
seeds and/or return. We usually treat these as unsigned integers.</p></div>
</dd>
<dt id="anarchy.rng.ID_BYTES"><code class="name">var <span class="ident">ID_BYTES</span></code></dt>
<dd>
<div class="desc"><p>The number of bytes in an "ID" value.</p></div>
</dd>
<dt id="anarchy.rng.ID_MASK"><code class="name">var <span class="ident">ID_MASK</span></code></dt>
<dd>
<div class="desc"><p>An "ID" value which is all-ones, to serve as a mask for preventing
overflow.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="anarchy.rng.byte_mask"><code class="name flex">
<span>def <span class="ident">byte_mask</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a mask that covers just the nth byte (zero-indexed), starting
from the least-significant digits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byte_mask(n):
    &#34;&#34;&#34;
    Returns a mask that covers just the nth byte (zero-indexed), starting
    from the least-significant digits.
    &#34;&#34;&#34;
    return (1 &lt;&lt; (8 * n)) * 0xff</code></pre>
</details>
</dd>
<dt id="anarchy.rng.exponential"><code class="name flex">
<span>def <span class="ident">exponential</span></span>(<span>seed, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters:</p>
<ul>
<li><code>seed</code> (int)&ndash;The seed that determines the result.</li>
<li><code>shape</code> (float):&ndash;The lambda shape parameter for the exponential
distribution. Values between 0.5 and 1.5 are typical, with higher
values biasing the distribution more towards smaller results.</li>
</ul>
<p>Returns (float): A number with an exponential distribution on [0,∞).</p>
<p>Generates a number from an exponential distribution with the given
lambda shape parameter.</p>
<p>See: <a href="https://math.stackexchange.com/questions/28004/random-exponential-like-distribution">this StackExchange answer on exponential
distribution</a>
and <a href="https://en.wikipedia.org/wiki/Exponential_distribution">the Wikipedia page for the exponential
distribution</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exponential(seed, shape):
    &#34;&#34;&#34;
    Parameters:

    - `seed` (int)--The seed that determines the result.
    - `shape` (float):--The lambda shape parameter for the exponential
      distribution. Values between 0.5 and 1.5 are typical, with higher
      values biasing the distribution more towards smaller results.

    Returns (float): A number with an exponential distribution on [0,∞).

    Generates a number from an exponential distribution with the given
    lambda shape parameter.

    See: [this StackExchange answer on exponential
    distribution](https://math.stackexchange.com/questions/28004/random-exponential-like-distribution)
    and [the Wikipedia page for the exponential
    distribution](https://en.wikipedia.org/wiki/Exponential_distribution)
    &#34;&#34;&#34; # noqa E501
    # Note: mathematically since u is on [0, 1) and not (0, 1], we can&#39;t
    # skip the 1- step, since when u = 0, that would be asking for the
    # log of 0. With 1-, the log of 0 would happen when u=1, but our
    # domain is [0, 1) which excludes 1.
    return -math.log(1 - uniform(seed)) / shape</code></pre>
</details>
</dd>
<dt id="anarchy.rng.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>p, seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters:</p>
<ul>
<li><code>p</code> (float): The probability of returning True.</li>
<li><code>seed</code> (int): The seed value that determines the result.</li>
</ul>
<p>Returns (True or False): a decision value.</p>
<p>Flips a biased coin with probability <code>p</code> of being true. Using the
same seed always gives the same result, but over many seeds the given
probability is adhered to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(p, seed):
    &#34;&#34;&#34;
    Parameters:

    - `p` (float): The probability of returning True.
    - `seed` (int): The seed value that determines the result.

    Returns (True or False): a decision value.

    Flips a biased coin with probability `p` of being true. Using the
    same seed always gives the same result, but over many seeds the given
    probability is adhered to.
    &#34;&#34;&#34;
    return uniform(prng(seed, seed)) &lt; p</code></pre>
</details>
</dd>
<dt id="anarchy.rng.flop"><code class="name flex">
<span>def <span class="ident">flop</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Flops each 1/2 byte with the adjacent 1/2 byte.</p>
<p>Flop is its own inverse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flop(x):
    &#34;&#34;&#34;
    Flops each 1/2 byte with the adjacent 1/2 byte.

    Flop is its own inverse.
    &#34;&#34;&#34;
    left = x &amp; FLOP_MASK
    right = x &amp; ~FLOP_MASK
    return ((right &lt;&lt; 4) | (left &gt;&gt; 4)) &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>x, where)</span>
</code></dt>
<dd>
<div class="desc"><p>Folds lower bits into upper bits using xor. 'where' is restricted to
fall between 1/4 and 1/2 of ID_BITS.</p>
<p>Fold is its own inverse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(x, where):
    &#34;&#34;&#34;
    Folds lower bits into upper bits using xor. &#39;where&#39; is restricted to
    fall between 1/4 and 1/2 of ID_BITS.

    Fold is its own inverse.
    &#34;&#34;&#34;
    quarter = ID_BITS // 4
    where = (where % quarter) + quarter
    m = mask(where)
    lower = x &amp; m
    shift_by = ID_BITS - where
    return (x ^ (lower &lt;&lt; shift_by)) &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.hash_string"><code class="name flex">
<span>def <span class="ident">hash_string</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>A string hashing function.</p>
<p>See: <a href="https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery">StackOverflow answer on hashing strings</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_string(s):
    &#34;&#34;&#34;
    A string hashing function.

    See: [StackOverflow answer on hashing strings](https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery).
    &#34;&#34;&#34; # noqa E501
    hash = 0
    if len(s) == 0:
        return hash

    for i, ch in enumerate(s):
        o = ord(ch)
        hash = ((hash &lt;&lt; 5) - hash) + o
        hash &amp;= ID_MASK

    return hash</code></pre>
</details>
</dd>
<dt id="anarchy.rng.integer"><code class="name flex">
<span>def <span class="ident">integer</span></span>(<span>seed, start, end)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li><code>seed</code> (int): The seed value that determines the result.</li>
<li><code>start</code> (int): The minimum possible output value.</li>
<li><code>end</code> (int): One more than the maximum possible output value.</li>
</ul>
<p>Returns (int): a pseudo-random integer between the start (inclusive)
and the end (exclusive).</p>
<p>Returns a number drawn evenly from the given integer range, including
the lower end but excluding the higher end (even if the lower end is
given second).</p>
<p>Distribution bias is about one part in (range/2^63).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integer(seed, start, end):
    &#34;&#34;&#34;
    Parameters:

      - `seed` (int): The seed value that determines the result.
      - `start` (int): The minimum possible output value.
      - `end` (int): One more than the maximum possible output value.

    Returns (int): a pseudo-random integer between the start (inclusive)
    and the end (exclusive).

    Returns a number drawn evenly from the given integer range, including
    the lower end but excluding the higher end (even if the lower end is
    given second).

    Distribution bias is about one part in (range/2^63).
    &#34;&#34;&#34;
    return math.floor(uniform(seed) * (end - start)) + start</code></pre>
</details>
</dd>
<dt id="anarchy.rng.lfsr"><code class="name flex">
<span>def <span class="ident">lfsr</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters:</p>
<ul>
<li><code>x</code> (int): The current random number.</li>
</ul>
<p>Returns (int): The next random number in a pseudo-random sequence.</p>
<p>Implements a max-cycle-length 64-bit linear-feedback-shift-register.
See: <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">the Wikipedia article on Linear Feedback Shift
Registers</a>.
Note that this is NOT reversible!</p>
<p>See also: <a href="http://courses.cse.tamu.edu/walker/csce680/lfsr_table.pdf">a PDF table of max-length LFSR
parameters</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lfsr(x):
    &#34;&#34;&#34;
    Parameters:

    - `x` (int): The current random number.

    Returns (int): The next random number in a pseudo-random sequence.

    Implements a max-cycle-length 64-bit linear-feedback-shift-register.
    See: [the Wikipedia article on Linear Feedback Shift
    Registers](https://en.wikipedia.org/wiki/Linear-feedback_shift_register).
    Note that this is NOT reversible!

    See also: [a PDF table of max-length LFSR
    parameters](http://courses.cse.tamu.edu/walker/csce680/lfsr_table.pdf).
    &#34;&#34;&#34;
    lsb = x &amp; 1
    r = x &gt;&gt; 1
    # pseudo-if
    r ^= lsb * 0xe800000000000000 # 64, 63, 61, 60

    return r &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>bits)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a mask with the given number of 1 bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(bits):
    &#34;&#34;&#34;
    Creates a mask with the given number of 1 bits.
    &#34;&#34;&#34;
    return (1 &lt;&lt; bits) - 1</code></pre>
</details>
</dd>
<dt id="anarchy.rng.normalish"><code class="name flex">
<span>def <span class="ident">normalish</span></span>(<span>seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameter (int): <code>seed</code>&ndash;The seed that determines the result.</p>
<p>Returns (float): A pseudo-random number between 0 (inclusive) and 1
(exclusive).</p>
<p>The result is created by averaging three results from <code><a title="anarchy.rng.uniform" href="#anarchy.rng.uniform">uniform()</a></code>, and
its distribution has a normal-like shape centered at 0.5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalish(seed):
    &#34;&#34;&#34;
    Parameter (int): `seed`--The seed that determines the result.

    Returns (float): A pseudo-random number between 0 (inclusive) and 1
      (exclusive).

    The result is created by averaging three results from `uniform`, and
    its distribution has a normal-like shape centered at 0.5.
    &#34;&#34;&#34;
    t = 0
    for i in range(3):
        t += uniform(seed + 9182793183 * i)
    return t / 3</code></pre>
</details>
</dd>
<dt id="anarchy.rng.posmod"><code class="name flex">
<span>def <span class="ident">posmod</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Modulus that's always positive (x % y) as long as y is positive.</p>
<p>Note: In python, the built-in % operator works this way, which is
what this function uses. It is retained for cross-language
compatibility, but in general the native operator should be preferred
as it's faster.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def posmod(x, y):
    &#34;&#34;&#34;
    Modulus that&#39;s always positive (x % y) as long as y is positive.

    Note: In python, the built-in % operator works this way, which is
    what this function uses. It is retained for cross-language
    compatibility, but in general the native operator should be preferred
    as it&#39;s faster.
    &#34;&#34;&#34;
    return x % y</code></pre>
</details>
</dd>
<dt id="anarchy.rng.prng"><code class="name flex">
<span>def <span class="ident">prng</span></span>(<span>x, seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters:</p>
<ul>
<li><code>x</code> (int): The current random number (next one is returned).</li>
<li><code>seed</code> (int): The seed; each seed will produce a distinct sequence
of numbers.</li>
</ul>
<p>Returns (int): The next random number in the sequence for the given
seed.</p>
<p>A reversible pseudo-random number generator. Uses low-level
reversible functions to scramble a number and produce an
hard-to-predict result. The <code><a title="anarchy.rng.rev_prng" href="#anarchy.rng.rev_prng">rev_prng()</a></code> function is the inverse of
this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prng(x, seed):
    &#34;&#34;&#34;
    Parameters:

    - `x` (int): The current random number (next one is returned).
    - `seed` (int): The seed; each seed will produce a distinct sequence
      of numbers.

    Returns (int): The next random number in the sequence for the given
    seed.

    A reversible pseudo-random number generator. Uses low-level
    reversible functions to scramble a number and produce an
    hard-to-predict result. The `rev_prng` function is the inverse of
    this function.
    &#34;&#34;&#34;

    # seed scrambling:
    seed = scramble_seed(seed)

    # value scrambling:
    x ^= seed
    x = fold(x, seed + 17) # prime
    x = flop(x)
    x = swirl(x, seed + 37) # prime
    x = fold(x, seed + 89) # prime
    x = swirl(x, seed + 107) # prime
    x = scramble(x)
    return x &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.rev_prng"><code class="name flex">
<span>def <span class="ident">rev_prng</span></span>(<span>x, seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters:</p>
<ul>
<li><code>x</code> (int): the current random number (previous one is returned).</li>
<li><code>seed</code> (int): The seed; each seed will produce a distinct
sequence of numbers.</li>
</ul>
<p>Returns (int): The previous random number in the sequence for the
given seed.</p>
<p>The inverse of <code><a title="anarchy.rng.prng" href="#anarchy.rng.prng">prng()</a></code> (see above). Returns the previous number in a
pseudo-random sequence, so that:</p>
<pre><code class="py">prng(rev_prng(n, seed), seed) == n
rev_prng(prng(n, seed), seed) == n
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rev_prng(x, seed):
    &#34;&#34;&#34;
    Parameters:

    - `x` (int): the current random number (previous one is returned).
    - `seed` (int): The seed; each seed will produce a distinct
    sequence of numbers.

    Returns (int): The previous random number in the sequence for the
    given seed.

    The inverse of `prng` (see above). Returns the previous number in a
    pseudo-random sequence, so that:

    ```py
    prng(rev_prng(n, seed), seed) == n
    rev_prng(prng(n, seed), seed) == n
    ```
    &#34;&#34;&#34;

    # seed scrambling:
    seed = scramble_seed(seed)

    # value unscrambling:
    x = rev_scramble(x)
    x = rev_swirl(x, seed + 107) # prime
    x = fold(x, seed + 89) # prime
    x = rev_swirl(x, seed + 37) # prime
    x = flop(x)
    x = fold(x, seed + 17) # prime
    x ^= seed
    return x &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.rev_scramble"><code class="name flex">
<span>def <span class="ident">rev_scramble</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse of <code><a title="anarchy.rng.scramble" href="#anarchy.rng.scramble">scramble()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rev_scramble(x):
    &#34;&#34;&#34;
    Inverse of `scramble`.
    &#34;&#34;&#34;
    pr = rev_swirl(x, 1)
    trigger = pr &amp; 0x80200003
    if trigger:
        # pr ^= rev_swirl(0x03040610, 1)
        pr ^= 0x06080c20

    return pr &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.rev_swirl"><code class="name flex">
<span>def <span class="ident">rev_swirl</span></span>(<span>x, distance)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse of <code><a title="anarchy.rng.swirl" href="#anarchy.rng.swirl">swirl()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rev_swirl(x, distance):
    &#34;&#34;&#34;
    Inverse of `swirl`.
    &#34;&#34;&#34;
    distance %= (3 * ID_BITS) // 4
    m = mask(distance)
    m = mask(distance)
    fall_off = x &amp; (m &lt;&lt; (ID_BITS - distance))
    shift_by = (ID_BITS - distance)
    return (
        (x &lt;&lt; distance)
      | (fall_off &gt;&gt; shift_by)
    ) &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.scramble"><code class="name flex">
<span>def <span class="ident">scramble</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements a reversible linear-feedback-shift-register-like operation.</p>
<p>Inverse is <code><a title="anarchy.rng.rev_scramble" href="#anarchy.rng.rev_scramble">rev_scramble()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scramble(x):
    &#34;&#34;&#34;
    Implements a reversible linear-feedback-shift-register-like operation.

    Inverse is `rev_scramble`.
    &#34;&#34;&#34;
    trigger = x &amp; 0x80200003
    r = swirl(x, 1)
    r ^= 0x03040610 * (not not trigger) # pseudo-if

    return r &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.scramble_seed"><code class="name flex">
<span>def <span class="ident">scramble_seed</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Scrambles a seed value to help separate RNG sequences generated from
sequential seeds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scramble_seed(s):
    &#34;&#34;&#34;
    Scrambles a seed value to help separate RNG sequences generated from
    sequential seeds.
    &#34;&#34;&#34;

    s = s &amp; ID_MASK
    s = ((s + 1) * (3 + (s % 23))) &amp; ID_MASK
    s = fold(s, 11) &amp; ID_MASK # prime
    s = scramble(s) &amp; ID_MASK
    s = swirl(s, s + 23) &amp; ID_MASK # prime
    s = scramble(s) &amp; ID_MASK
    s ^= (s % 153) * scramble(s)
    s = s &amp; ID_MASK

    return s</code></pre>
</details>
</dd>
<dt id="anarchy.rng.swirl"><code class="name flex">
<span>def <span class="ident">swirl</span></span>(<span>x, distance)</span>
</code></dt>
<dd>
<div class="desc"><p>Circular bit shift. Distance is capped at 3/4 of ID_BITS.</p>
<p>Inverse is <code><a title="anarchy.rng.rev_swirl" href="#anarchy.rng.rev_swirl">rev_swirl()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swirl(x, distance):
    &#34;&#34;&#34;
    Circular bit shift. Distance is capped at 3/4 of ID_BITS.

    Inverse is `rev_swirl`.
    &#34;&#34;&#34;
    distance %= (3 * ID_BITS) // 4
    m = mask(distance)
    fall_off = x &amp; m
    shift_by = (ID_BITS - distance)
    return (
        (x &gt;&gt; distance)
      | (fall_off &lt;&lt; shift_by)
    ) &amp; ID_MASK</code></pre>
</details>
</dd>
<dt id="anarchy.rng.truncated_exponential"><code class="name flex">
<span>def <span class="ident">truncated_exponential</span></span>(<span>seed, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters:</p>
<ul>
<li><code>seed</code> (int)&ndash;The seed that determines the result.</li>
<li><code>shape</code> (float)&ndash;The lambda shape parameter for the exponential
distribution. Values between 0.5 and 1.5 are typical, with higher
values biasing the distribution more towards smaller results.</li>
</ul>
<p>Returns (float) A number with a truncated exponential distribution
on [0, 1].</p>
<p>Generates a number from a truncated exponential distribution on [0,
1] with the given lambda shape parameter. See reference material for
<code><a title="anarchy.rng.exponential" href="#anarchy.rng.exponential">exponential()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncated_exponential(seed, shape):
    &#34;&#34;&#34;
    Parameters:

    - `seed` (int)--The seed that determines the result.
    - `shape` (float)--The lambda shape parameter for the exponential
      distribution. Values between 0.5 and 1.5 are typical, with higher
      values biasing the distribution more towards smaller results.

    Returns (float) A number with a truncated exponential distribution
    on [0, 1].

    Generates a number from a truncated exponential distribution on [0,
    1] with the given lambda shape parameter. See reference material for
    `exponential`.
    &#34;&#34;&#34;
    e = exponential(seed, shape)
    return e - math.floor(e)</code></pre>
</details>
</dd>
<dt id="anarchy.rng.uniform"><code class="name flex">
<span>def <span class="ident">uniform</span></span>(<span>seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameter (int): <code>seed</code>&ndash;The seed that determines the result (could
be a result from <code><a title="anarchy.rng.prng" href="#anarchy.rng.prng">prng()</a></code> or <code><a title="anarchy.rng.lfsr" href="#anarchy.rng.lfsr">lfsr()</a></code>)</p>
<p>Returns (float): A pseudo-random number between 0 (inclusive) and 1
(exclusive).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform(seed):
    &#34;&#34;&#34;
    Parameter (int): `seed`--The seed that determines the result (could
      be a result from `prng` or `lfsr`)

    Returns (float): A pseudo-random number between 0 (inclusive) and 1
      (exclusive).
    &#34;&#34;&#34;
    # Note: without this extra scrambling, udist on sequential seeds is
    # *terrible* for seeds below ~1000000.
    sc = scramble_seed(seed)
    sc = prng(prng(sc, sc), seed)
    return (sc % 9223372036854775783) / 9223372036854775783 # prime near 2^63</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="anarchy" href="index.html">anarchy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="anarchy.rng.FLOP_MASK" href="#anarchy.rng.FLOP_MASK">FLOP_MASK</a></code></li>
<li><code><a title="anarchy.rng.ID_BITS" href="#anarchy.rng.ID_BITS">ID_BITS</a></code></li>
<li><code><a title="anarchy.rng.ID_BYTES" href="#anarchy.rng.ID_BYTES">ID_BYTES</a></code></li>
<li><code><a title="anarchy.rng.ID_MASK" href="#anarchy.rng.ID_MASK">ID_MASK</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="anarchy.rng.byte_mask" href="#anarchy.rng.byte_mask">byte_mask</a></code></li>
<li><code><a title="anarchy.rng.exponential" href="#anarchy.rng.exponential">exponential</a></code></li>
<li><code><a title="anarchy.rng.flip" href="#anarchy.rng.flip">flip</a></code></li>
<li><code><a title="anarchy.rng.flop" href="#anarchy.rng.flop">flop</a></code></li>
<li><code><a title="anarchy.rng.fold" href="#anarchy.rng.fold">fold</a></code></li>
<li><code><a title="anarchy.rng.hash_string" href="#anarchy.rng.hash_string">hash_string</a></code></li>
<li><code><a title="anarchy.rng.integer" href="#anarchy.rng.integer">integer</a></code></li>
<li><code><a title="anarchy.rng.lfsr" href="#anarchy.rng.lfsr">lfsr</a></code></li>
<li><code><a title="anarchy.rng.mask" href="#anarchy.rng.mask">mask</a></code></li>
<li><code><a title="anarchy.rng.normalish" href="#anarchy.rng.normalish">normalish</a></code></li>
<li><code><a title="anarchy.rng.posmod" href="#anarchy.rng.posmod">posmod</a></code></li>
<li><code><a title="anarchy.rng.prng" href="#anarchy.rng.prng">prng</a></code></li>
<li><code><a title="anarchy.rng.rev_prng" href="#anarchy.rng.rev_prng">rev_prng</a></code></li>
<li><code><a title="anarchy.rng.rev_scramble" href="#anarchy.rng.rev_scramble">rev_scramble</a></code></li>
<li><code><a title="anarchy.rng.rev_swirl" href="#anarchy.rng.rev_swirl">rev_swirl</a></code></li>
<li><code><a title="anarchy.rng.scramble" href="#anarchy.rng.scramble">scramble</a></code></li>
<li><code><a title="anarchy.rng.scramble_seed" href="#anarchy.rng.scramble_seed">scramble_seed</a></code></li>
<li><code><a title="anarchy.rng.swirl" href="#anarchy.rng.swirl">swirl</a></code></li>
<li><code><a title="anarchy.rng.truncated_exponential" href="#anarchy.rng.truncated_exponential">truncated_exponential</a></code></li>
<li><code><a title="anarchy.rng.uniform" href="#anarchy.rng.uniform">uniform</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>